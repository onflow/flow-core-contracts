{
  "network": "testnet",
  "templates": [
    {
      "id": "FA.01",
      "name": "Create Account",
      "source": "import Crypto\n\ntransaction(key: String, signatureAlgorithm: UInt8, hashAlgorithm: UInt8, weight: UFix64) {\n\tprepare(signer: auth(BorrowValue, Storage) \u0026Account) {\n\t\tpre {\n\t\t\tsignatureAlgorithm \u003e= 1 \u0026\u0026 signatureAlgorithm \u003c= 3: \"Must provide a signature algoritm raw value that is 1, 2, or 3\"\n\t\t\thashAlgorithm \u003e= 1 \u0026\u0026 hashAlgorithm \u003c= 6: \"Must provide a hash algoritm raw value that is between 1 and 6\"\n\t\t\tweight \u003c= 1000.0: \"The key weight must be between 0 and 1000\"\n\t\t}\n\n\t\tlet publicKey = PublicKey(\n\t\t\tpublicKey: key.decodeHex(),\n\t\t\tsignatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!\n\t\t)\n\n\t\tlet account = Account(payer: signer)\n\n\t\taccount.keys.add(publicKey: publicKey, hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!, weight: weight)\n\t}\n}",
      "arguments": [
        {
          "type": "String",
          "name": "key",
          "label": "Public Key",
          "sampleValues": [
            {
              "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "signatureAlgorithm",
          "label": "Raw Value for Signature Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "hashAlgorithm",
          "label": "Raw Value for Hash Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "weight",
          "label": "Key Weight",
          "sampleValues": [
            {
              "value": "1000.00000000",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "63d8b6a045bf8e6196198184db685c2cf22932503ccb2dcb85c7d2dc04c882ba"
    },
    {
      "id": "FA.02",
      "name": "Add Key",
      "source": "import Crypto\n\ntransaction(key: String, signatureAlgorithm: UInt8, hashAlgorithm: UInt8, weight: UFix64) {\n\n\tprepare(signer: auth(AddKey) \u0026Account) {\n\t\tpre {\n\t\t\tsignatureAlgorithm \u003e= 1 \u0026\u0026 signatureAlgorithm \u003c= 3: \"Must provide a signature algoritm raw value that is 1, 2, or 3\"\n\t\t\thashAlgorithm \u003e= 1 \u0026\u0026 hashAlgorithm \u003c= 6: \"Must provide a hash algoritm raw value that is between 1 and 6\"\n\t\t\tweight \u003c= 1000.0: \"The key weight must be between 0 and 1000\"\n\t\t}\n\t\tlet publicKey = PublicKey(\n\t\t\tpublicKey: key.decodeHex(),\n\t\t\tsignatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!\n\t\t)\n\n\t\tsigner.keys.add(publicKey: publicKey, hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!, weight: weight)\n\t}\n}",
      "arguments": [
        {
          "type": "String",
          "name": "key",
          "label": "Public Key",
          "sampleValues": [
            {
              "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "signatureAlgorithm",
          "label": "Raw Value for Signature Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "hashAlgorithm",
          "label": "Raw Value for Hash Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "weight",
          "label": "Key Weight",
          "sampleValues": [
            {
              "value": "1000.00000000",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "21d4e87df171ccbe015efe69dc2ffd24814c5fc0f2e364daf5c80515ce4a8bd9"
    },
    {
      "id": "FA.03",
      "name": "Remove Key",
      "source": "transaction(keyIndex: Int) {\n\tprepare(signer: auth(RevokeKey) \u0026Account) {\n\t\tif let key = signer.keys.get(keyIndex: keyIndex) {\n\t\t\tsigner.keys.revoke(keyIndex: keyIndex)\n\t\t} else {\n\t\t\tpanic(\"No key with the given index exists on the authorizer's account\")\n\t\t}\n\t}\n}",
      "arguments": [
        {
          "type": "Int",
          "name": "keyIndex",
          "label": "Key Index",
          "sampleValues": [
            {
              "value": "1",
              "type": "Int"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "6c7ab72837fdce77a910f6fc0c622c6c4d5b17f6fbf7295f345d50d3508dd515"
    },
    {
      "id": "FT.01",
      "name": "Setup Fungible Token Vault",
      "source": "import FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenMetadataViews from 0x9a0766d93b6608b7\n\n/// This transaction is what an account would run\n/// to set itself up to manage fungible tokens. This function\n/// uses views to know where to set up the vault\n/// in storage and to create the empty vault.\n\ntransaction(contractAddress: Address, contractName: String) {\n\n    prepare(signer: auth(SaveValue, Capabilities) \u0026Account) {\n        // Borrow a reference to the vault stored on the passed account at the passed publicPath\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow\u003c\u0026FungibleToken\u003e(name: contractName)\n            ?? panic(\"Could not borrow a reference to the fungible token contract\")\n\n        // Use that reference to retrieve the FTView \n        let ftVaultData = resolverRef.resolveContractView(resourceType: nil, viewType: Type\u003cFungibleTokenMetadataViews.FTVaultData\u003e()) as! FungibleTokenMetadataViews.FTVaultData?\n            ?? panic(\"Could not resolve the FTVaultData view for the given Fungible token contract\")\n\n        // Create a new empty vault using the createEmptyVault function inside the FTVaultData\n        let emptyVault \u003c-ftVaultData.createEmptyVault()\n\n        // Save it to the account\n        signer.storage.save(\u003c-emptyVault, to: ftVaultData.storagePath)\n        \n        // Create a public capability for the vault which includes the .Resolver interface\n        let vaultCap = signer.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(ftVaultData.storagePath)\n        signer.capabilities.publish(vaultCap, at: ftVaultData.metadataPath)\n\n        // Create a public capability for the vault exposing the receiver interface\n        let receiverCap = signer.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(ftVaultData.storagePath)\n        signer.capabilities.publish(receiverCap, at: ftVaultData.receiverPath)\n\n    }\n}\n ",
      "arguments": [
        {
          "type": "Address",
          "name": "contractAddress",
          "label": "FT Contract Address",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "contractName",
          "label": "FT Contract Name",
          "sampleValues": [
            {
              "value": "FiatToken",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "61eb858316b62fedbec6a9d155076a4f394315edaa91a6335b267d2efbea255e"
    },
    {
      "id": "FT.02",
      "name": "Transfer Fungible Token with Paths",
      "source": "import FungibleToken from 0x9a0766d93b6608b7\n\n/// Can pass in any storage path and receiver path identifier instead of just the default.\n/// This lets you choose the token you want to send as well the capability you want to send it to.\n///\n/// Any token path can be passed as an argument here, so wallets should\n/// should check argument values to make sure the intended token path is passed in\n///\ntransaction(amount: UFix64, to: Address, senderPathIdentifier: String, receiverPathIdentifier: String) {\n\n    // The Vault resource that holds the tokens that are being transferred\n    let tempVault: @{FungibleToken.Vault}\n\n    prepare(signer: auth(BorrowValue) \u0026Account) {\n\n        let storagePath = StoragePath(identifier: senderPathIdentifier)\n            ?? panic(\"Could not construct a storage path from the provided path identifier string\")\n\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Provider}\u003e(from: storagePath)\n\t\t\t?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n        self.tempVault \u003c- vaultRef.withdraw(amount: amount)\n    }\n\n    execute {\n        let publicPath = PublicPath(identifier: receiverPathIdentifier)\n            ?? panic(\"Could not construct a public path from the provided path identifier string\")\n\n        let recipient = getAccount(to)\n        let receiverRef = recipient.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(publicPath)\n            ?? panic(\"Could not borrow reference to the recipient's Receiver!\")\n\n        // Transfer tokens from the signer's stored vault to the receiver capability\n        receiverRef.deposit(from: \u003c-self.tempVault)\n    }\n}",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        },
        {
          "type": "Address",
          "name": "to",
          "label": "Recipient",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "senderPathIdentifier",
          "label": "Sender's Collection Path Identifier",
          "sampleValues": [
            {
              "value": "flowTokenVault",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "receiverPathIdentifier",
          "label": "Recipient's Receiver Path Identifier",
          "sampleValues": [
            {
              "value": "flowTokenReceiver",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "c9b9a6156280812703c15dde74df95cd0d7d1034dd2d8bf0cccf72b607142988"
    },
    {
      "id": "FT.03",
      "name": "Transfer Fungible Token with Address",
      "source": "import FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenMetadataViews from 0x9a0766d93b6608b7\n\n/// Can pass in any contract address and name to transfer a token from that contract\n/// This lets you choose the token you want to send\n///\n/// Any contract can be chosen here, so wallets should check argument values\n/// to make sure the intended token path is passed in\n///\ntransaction(amount: UFix64, to: Address, contractAddress: Address, contractName: String) {\n\n    // The Vault resource that holds the tokens that are being transferred\n    let tempVault: @{FungibleToken.Vault}\n\n    // FTVaultData struct to get paths from\n    let vaultData: FungibleTokenMetadataViews.FTVaultData\n\n    prepare(signer: auth(BorrowValue) \u0026Account) {\n\n        // Borrow a reference to the vault stored on the passed account at the passed publicPath\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow\u003c\u0026FungibleToken\u003e(name: contractName)\n            ?? panic(\"Could not borrow a reference to the fungible token contract\")\n\n        // Use that reference to retrieve the FTView \n        self.vaultData = resolverRef.resolveContractView(resourceType: nil, viewType: Type\u003cFungibleTokenMetadataViews.FTVaultData\u003e()) as! FungibleTokenMetadataViews.FTVaultData?\n            ?? panic(\"Could not resolve the FTVaultData view for the given Fungible token contract\")\n\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Provider}\u003e(from: self.vaultData.storagePath)\n\t\t\t?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n        self.tempVault \u003c- vaultRef.withdraw(amount: amount)\n    }\n\n    execute {\n        let recipient = getAccount(to)\n        let receiverRef = recipient.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(self.vaultData.receiverPath)\n            ?? panic(\"Could not borrow reference to the recipient's Receiver!\")\n\n        // Transfer tokens from the signer's stored vault to the receiver capability\n        receiverRef.deposit(from: \u003c-self.tempVault)\n    }\n}",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        },
        {
          "type": "Address",
          "name": "to",
          "label": "Recipient",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        },
        {
          "type": "Address",
          "name": "contractAddress",
          "label": "FT Contract Address",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "contractName",
          "label": "FT Contract Name",
          "sampleValues": [
            {
              "value": "FiatToken",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "53afddb176f6838569124f85d06da085b69ebaa6b81dcfeb00fb9199d48a7197"
    },
    {
      "id": "NFT.01",
      "name": "Setup NFT Collection",
      "source": "/// This transaction is what an account would run\n/// to set itself up to receive NFTs. This function\n/// uses views to know where to set up the collection\n/// in storage and to create the empty collection.\n\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction(contractAddress: Address, contractName: String) {\n\n    prepare(signer: auth(IssueStorageCapabilityController, PublishCapability, SaveValue) \u0026Account) {\n        // Borrow a reference to the nft contract deployed to the passed account\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow\u003c\u0026NonFungibleToken\u003e(name: contractName)\n            ?? panic(\"Could not borrow a reference to the non-fungible token contract\")\n\n        // Use that reference to retrieve the NFTCollectionData view \n        let collectionData = resolverRef.resolveContractView(resourceType: nil, viewType: Type\u003cMetadataViews.NFTCollectionData\u003e()) as! MetadataViews.NFTCollectionData?\n            ?? panic(\"Could not resolve the NFTCollectionData view for the given non-fungible token contract\")\n\n        // Create a new empty collections\n        let emptyCollection \u003c- collectionData.createEmptyCollection()\n\n        // save it to the account\n        signer.storage.save(\u003c-emptyCollection, to: collectionData.storagePath)\n\n        // create a public capability for the collection\n        let collectionCap = signer.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(\n                collectionData.storagePath\n            )\n        signer.capabilities.publish(collectionCap, at: collectionData.publicPath)\n    }\n}\n",
      "arguments": [
        {
          "type": "Address",
          "name": "contractAddress",
          "label": "NFT Contract Address",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "contractName",
          "label": "NFT Contract Name",
          "sampleValues": [
            {
              "value": "TopShot",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "98966f4ef503ab75eeebe2d24d2dd3d2fb92d7d945db5bc76f79a6c60070bd33"
    },
    {
      "id": "NFT.02",
      "name": "Transfer NFT with Paths",
      "source": "import NonFungibleToken from 0x631e88ae7f1d7c20\n\n/// Can pass in any storage path and receiver path instead of just the default.\n/// This lets you choose the token you want to send as well the capability you want to send it to.\n///\n/// Any token path can be passed as an argument here, so wallets should\n/// should check argument values to make sure the intended token path is passed in\n///\ntransaction(to: Address, id: UInt64, senderPathIdentifier: String, receiverPathIdentifier: String) {\n\n    // The NFT resource to be transferred\n    let tempNFT: @{NonFungibleToken.NFT}\n\n    prepare(signer: auth(BorrowValue) \u0026Account) {\n\n        let storagePath = StoragePath(identifier: senderPathIdentifier)\n            ?? panic(\"Could not construct a storage path from the provided path identifier string\")\n\n        // borrow a reference to the signer's NFT collection\n        let withdrawRef = signer.storage.borrow\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(\n                from: storagePath\n            ) ?? panic(\"Account does not store a collection object at the specified path\")\n\n        self.tempNFT \u003c- withdrawRef.withdraw(withdrawID: id)\n    }\n\n    execute {\n        let publicPath = PublicPath(identifier: receiverPathIdentifier)\n            ?? panic(\"Could not construct a public path from the provided path identifier string\")\n\n        // get the recipients public account object\n        let recipient = getAccount(to)\n\n        // borrow a public reference to the receivers collection\n        let receiverCap = recipient.capabilities.get\u003c\u0026{NonFungibleToken.Receiver}\u003e(publicPath)\n            ?? panic(\"Could not get the recipient's Receiver Capability\")\n\n        let receiverRef = receiverCap.borrow()\n            ?? panic(\"Could not borrow reference to the recipient's receiver\")\n\n        // Deposit the NFT to the receiver\n        receiverRef.deposit(token: \u003c-self.tempNFT)\n    }\n}",
      "arguments": [
        {
          "type": "Address",
          "name": "to",
          "label": "Recipient",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        },
        {
          "type": "UInt64",
          "name": "id",
          "label": "NFT ID to Transfer",
          "sampleValues": [
            {
              "value": "10",
              "type": "UInt64"
            }
          ]
        },
        {
          "type": "String",
          "name": "senderPathIdentifier",
          "label": "Sender's Collection Path Identifier",
          "sampleValues": [
            {
              "value": "flowTokenVault",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "receiverPathIdentifier",
          "label": "Recipient's Receiver Path Identifier",
          "sampleValues": [
            {
              "value": "flowTokenReceiver",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "267278a2c41182ced41877d4ecdec086e07ee152d17e8f5b8ba910b9c91aabde"
    },
    {
      "id": "NFT.03",
      "name": "Transfer NFT with Address",
      "source": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n/// Can pass in any contract address and name\n/// This lets you choose the token you want to send because\n/// the transaction gets the metadata from the provided contract.\n///\ntransaction(to: Address, id: UInt64, contractAddress: Address, contractName: String) {\n\n    // The NFT resource to be transferred\n    let tempNFT: @{NonFungibleToken.NFT}\n\n    // NFTCollectionData struct to get paths from\n    let collectionData: MetadataViews.NFTCollectionData\n\n    prepare(signer: auth(BorrowValue) \u0026Account) {\n\n        // Borrow a reference to the nft contract deployed to the passed account\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow\u003c\u0026NonFungibleToken\u003e(name: contractName)\n            ?? panic(\"Could not borrow a reference to the non-fungible token contract\")\n\n        // Use that reference to retrieve the NFTCollectionData view \n        self.collectionData = resolverRef.resolveContractView(resourceType: nil, viewType: Type\u003cMetadataViews.NFTCollectionData\u003e()) as! MetadataViews.NFTCollectionData?\n            ?? panic(\"Could not resolve the NFTCollectionData view for the given non-fungible token contract\")\n\n\n        // borrow a reference to the signer's NFT collection\n        let withdrawRef = signer.storage.borrow\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(\n                from: self.collectionData.storagePath\n            ) ?? panic(\"Account does not store a collection object at the specified path\")\n\n        self.tempNFT \u003c- withdrawRef.withdraw(withdrawID: id)\n    }\n\n    execute {\n        // get the recipients public account object\n        let recipient = getAccount(to)\n\n        // borrow a public reference to the receivers collection\n        let receiverCap = recipient.capabilities.get\u003c\u0026{NonFungibleToken.Receiver}\u003e(self.collectionData.publicPath)\n            ?? panic(\"Could not get the recipient's Receiver Capability\")\n\n        let receiverRef = receiverCap.borrow()\n            ?? panic(\"Could not borrow reference to the recipient's receiver\")\n\n        // Deposit the NFT to the receiver\n        receiverRef.deposit(token: \u003c-self.tempNFT)\n    }\n}",
      "arguments": [
        {
          "type": "Address",
          "name": "to",
          "label": "Recipient",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        },
        {
          "type": "UInt64",
          "name": "id",
          "label": "NFT ID to Transfer",
          "sampleValues": [
            {
              "value": "10",
              "type": "UInt64"
            }
          ]
        },
        {
          "type": "Address",
          "name": "contractAddress",
          "label": "NFT Contract Address",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "contractName",
          "label": "NFT Contract Name",
          "sampleValues": [
            {
              "value": "TopShot",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "977f1fab609f8845472f60a23d163d810a09c0eefc111fab70e816a789a0ca7a"
    },
    {
      "id": "TH.01",
      "name": "Withdraw Unlocked FLOW",
      "source": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport LockedTokens from 0x95e019a17d0e23d7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.holderRef = acct.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"The primary user account does not have an associated locked account\")\n\n        self.vaultRef = acct.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow flow token vault ref\")\n    }\n\n    execute {\n        self.vaultRef.deposit(from: \u003c-self.holderRef.withdraw(amount: amount))\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "094798e93daeacaa9ff262486a3683ec5a5e2204407e7d00bc3416fbf3efa3b1"
    },
    {
      "id": "TH.02",
      "name": "Deposit Unlocked FLOW",
      "source": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport LockedTokens from 0x95e019a17d0e23d7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: \u0026LockedTokens.TokenHolder\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.holderRef = acct.storage.borrow\u003c\u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"The primary user account does not have an associated locked account\")\n\n        self.vaultRef = acct.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow flow token vault ref\")\n    }\n\n    execute {\n        self.holderRef.deposit(from: \u003c-self.vaultRef.withdraw(amount: amount))\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "17ffcd60667893674d8d4044bdd8232959dc8b694df1dd88d1b9c5443352f253"
    },
    {
      "id": "SCO.01",
      "name": "Setup Staking Collection",
      "source": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport FlowIDTableStaking from 0x9eca2b38b18b5dfe\nimport LockedTokens from 0x95e019a17d0e23d7\nimport FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// This transaction sets up an account to use a staking collection\n/// It will work regardless of whether they have a regular account, a two-account locked tokens setup,\n/// or staking objects stored in the unlocked account\n\ntransaction {\n    prepare(signer: auth(BorrowValue, Storage, Capabilities) \u0026Account) {\n\n        // If there isn't already a staking collection\n        if signer.storage.borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath) == nil {\n\n            // Create private capabilities for the token holder and unlocked vault\n            let lockedHolder = signer.capabilities.storage.issue\u003cauth(FungibleToken.Withdraw, LockedTokens.TokenOperations) \u0026LockedTokens.TokenHolder\u003e(LockedTokens.TokenHolderStoragePath)!\n            let flowToken = signer.capabilities.storage.issue\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(/storage/flowTokenVault)!\n\n            // Create a new Staking Collection and put it in storage\n            if lockedHolder.check() {\n                signer.storage.save(\n                    \u003c- FlowStakingCollection.createStakingCollection(\n                        unlockedVault: flowToken,\n                        tokenHolder: lockedHolder\n                    ),\n                    to: FlowStakingCollection.StakingCollectionStoragePath\n                )\n            } else {\n                signer.storage.save(\n                    \u003c- FlowStakingCollection.createStakingCollection(\n                        unlockedVault: flowToken,\n                        tokenHolder: nil\n                    ),\n                    to: FlowStakingCollection.StakingCollectionStoragePath\n                )\n            }\n\n            // Publish a capability to the created staking collection.\n            let stakingCollectionCap = signer.capabilities.storage.issue\u003c\u0026FlowStakingCollection.StakingCollection\u003e(\n                FlowStakingCollection.StakingCollectionStoragePath\n            )\n\n            signer.capabilities.publish(\n                stakingCollectionCap,\n                at: FlowStakingCollection.StakingCollectionPublicPath\n            )\n        }\n\n        // borrow a reference to the staking collection\n        let collectionRef = signer.storage.borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow staking collection reference\")\n\n        // If there is a node staker object in the account, put it in the staking collection\n        if signer.storage.borrow\u003c\u0026FlowIDTableStaking.NodeStaker\u003e(from: FlowIDTableStaking.NodeStakerStoragePath) != nil {\n            let node \u003c- signer.storage.load\u003c@FlowIDTableStaking.NodeStaker\u003e(from: FlowIDTableStaking.NodeStakerStoragePath)!\n            collectionRef.addNodeObject(\u003c-node, machineAccountInfo: nil)\n        }\n\n        // If there is a delegator object in the account, put it in the staking collection\n        if signer.storage.borrow\u003c\u0026FlowIDTableStaking.NodeDelegator\u003e(from: FlowIDTableStaking.DelegatorStoragePath) != nil {\n            let delegator \u003c- signer.storage.load\u003c@FlowIDTableStaking.NodeDelegator\u003e(from: FlowIDTableStaking.DelegatorStoragePath)!\n            collectionRef.addDelegatorObject(\u003c-delegator)\n        }\n    }\n}\n",
      "arguments": [],
      "network": "testnet",
      "hash": "861784e7ac135a9cfec90decdff2e53971a4d63135db77bcef3b273b710b1814"
    },
    {
      "id": "SCO.02",
      "name": "Register Delegator",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Registers a delegator in the staking collection resource\n/// for the specified nodeID and the amount of tokens to commit\n\ntransaction(id: String, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.registerDelegator(nodeID: id, amount: amount)      \n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "e093df9c425be9cdbee44bdbbd721f6aff523e41802a50cf0ff353873e9f9483"
    },
    {
      "id": "SCO.03",
      "name": "Register Node",
      "source": "import Crypto\nimport FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Registers a delegator in the staking collection resource\n/// for the specified node information and the amount of tokens to commit\n\ntransaction(id: String,\n            role: UInt8,\n            networkingAddress: String,\n            networkingKey: String,\n            stakingKey: String,\n            amount: UFix64,\n            publicKeys: [Crypto.KeyListEntry]?) {\n\n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n\n        if let machineAccount = self.stakingCollectionRef.registerNode(\n            id: id,\n            role: role,\n            networkingAddress: networkingAddress,\n            networkingKey: networkingKey,\n            stakingKey: stakingKey,\n            amount: amount,\n            payer: account\n        ) {\n            if publicKeys == nil || publicKeys!.length == 0 {\n                panic(\"Cannot provide zero keys for the machine account\")\n            }\n            for key in publicKeys! {\n                machineAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)\n            }\n        }\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "role",
          "label": "Node Role",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingAddress",
          "label": "Networking Address",
          "sampleValues": [
            {
              "value": "flow-node.test:3569",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingKey",
          "label": "Networking Key",
          "sampleValues": [
            {
              "value": "1348307bc77c688e80049de9d081aa09755da33e6997605fa059db2144fc85e560cbe6f7da8d74b453f5916618cb8fd392c2db856f3e78221dc68db1b1d914e4",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "stakingKey",
          "label": "Staking Key",
          "sampleValues": [
            {
              "value": "9e9ae0d645fd5fd9050792e0b0daa82cc1686d9133afa0f81a784b375c42ae48567d1545e7a9e1965f2c1a32f73cf8575ebb7a967f6e4d104d2df78eb8be409135d12da0499b8a00771f642c1b9c49397f22b440439f036c3bdee82f5309dab3",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        },
        {
          "type": "[String]?",
          "name": "publicKeys",
          "label": "Public Keys",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": [],
                "type": "Array"
              },
              "type": "Optional"
            },
            {
              "value": {
                "value": [
                  {
                    "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                    "type": "String"
                  }
                ],
                "type": "Array"
              },
              "type": "Optional"
            },
            {
              "value": {
                "value": [
                  {
                    "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                    "type": "String"
                  },
                  {
                    "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                    "type": "String"
                  },
                  {
                    "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                    "type": "String"
                  }
                ],
                "type": "Array"
              },
              "type": "Optional"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "ea29e83e0a6e6d4382001a9e2e0397b6ee19be4fb5850c29f271673f2db85b3a"
    },
    {
      "id": "SCO.04",
      "name": "Create Machine Account",
      "source": "import Crypto\nimport FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Creates a machine account for a node that is already in the staking collection\n/// and adds public keys to the new account\n\ntransaction(nodeID: String, publicKeys: [Crypto.KeyListEntry]) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n\n        if let machineAccount = self.stakingCollectionRef.createMachineAccountForExistingNode(nodeID: nodeID, payer: account) {\n            if publicKeys == nil || publicKeys!.length == 0 {\n                panic(\"Cannot provide zero keys for the machine account\")\n            }\n            for key in publicKeys {\n                machineAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)\n            }\n        } else {\n            panic(\"Could not create a machine account for the node\")\n        }\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "[String]",
          "name": "publicKeys",
          "label": "Public Keys",
          "sampleValues": [
            {
              "value": [],
              "type": "Array"
            },
            {
              "value": [
                {
                  "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                  "type": "String"
                }
              ],
              "type": "Array"
            },
            {
              "value": [
                {
                  "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                  "type": "String"
                },
                {
                  "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                  "type": "String"
                },
                {
                  "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                  "type": "String"
                }
              ],
              "type": "Array"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "bb2b73496d87ca467d5409fa41901ab80ec02d41a66b5c097b4f60625e11c69d"
    },
    {
      "id": "SCO.05",
      "name": "Request Unstaking",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Requests unstaking for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.requestUnstaking(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "2d59f2c2c402f919c8dba30009e31480d54e2b250d2e10456e1ff029bd7cce99"
    },
    {
      "id": "SCO.06",
      "name": "Stake New Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Commits new tokens to stake for the specified node or delegator in the staking collection\n/// The tokens from the locked vault are used first, if it exists\n/// followed by the tokens from the unlocked vault\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.stakeNewTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "cf2b03950077352487e6344ab65edc3e1856731ab9cf68aa2ebbe279ae496d4b"
    },
    {
      "id": "SCO.07",
      "name": "Stake Rewarded Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Commits rewarded tokens to stake for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.stakeRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "4395faf2e515eea4d40f82416ad387575f0d5a580612223c361130e53e72f00b"
    },
    {
      "id": "SCO.08",
      "name": "Stake Unstaked Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Commits unstaked tokens to stake for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.stakeUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "0b1721f2a8ef6c0c4121ef83c7b38f2141eebcd65c72dab9ebaafe1b4d66fea8"
    },
    {
      "id": "SCO.09",
      "name": "Unstake All",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Requests to unstake ALL tokens for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.unstakeAll(nodeID: nodeID)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "c84843e3399be2ce95ea00e7c17d72db3c5c3363ec008c7a1c1cfa5b6afe70ae"
    },
    {
      "id": "SCO.10",
      "name": "Withdraw Rewarded Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Request to withdraw rewarded tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.withdrawRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            },
            {
              "value": null,
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "5a07ca4c016973bdeb168590e111b2c2855833b5ece11ffb28b08b8668f258a8"
    },
    {
      "id": "SCO.11",
      "name": "Withdraw Unstaked Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Request to withdraw unstaked tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault if it is there\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.withdrawUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "01fd4ea83d20510d24ed9f245873a7ee2715aefb774495c80bce7e3e34d6442e"
    },
    {
      "id": "SCO.12",
      "name": "Close Stake",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n// Closes out a staking object in the staking collection\n// This does not remove the record from the identity table,\n// but it does mean that the account that closes it cannot ever access it again\n\ntransaction(nodeID: String, delegatorID: UInt32?) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.closeStake(nodeID: nodeID, delegatorID: delegatorID)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            },
            {
              "value": null,
              "type": "Optional"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "7e216d96d75414b27c2301a3b0a7816804d43014337a14731d1493531116d185"
    },
    {
      "id": "SCO.13",
      "name": "Transfer Node",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n// Transfers a NodeStaker object from an authorizers accoount\n// and adds the NodeStaker to another accounts Staking Collection\n// identified by the to Address.\n\ntransaction(nodeID: String, to: Address) {\n    let fromStakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        // The account to transfer the NodeStaker object to must have a valid Staking Collection in order to receive the NodeStaker.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(\"Destination account must have a Staking Collection set up.\")\n        }\n\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n\n        // Get the PublicAccount of the account to transfer the NodeStaker to. \n        let toAccount = getAccount(to)\n\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.capabilities\n            .borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(FlowStakingCollection.StakingCollectionPublicPath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the receiver's account\")\n\n        let machineAccountInfo = self.fromStakingCollectionRef.getMachineAccounts()[nodeID]\n            ?? panic(\"Could not get machine account info for the specified node ID\")\n\n        // Remove the NodeStaker from the authorizers StakingCollection.\n        let nodeStaker \u003c- self.fromStakingCollectionRef.removeNode(nodeID: nodeID)\n\n        // Deposit the NodeStaker to the receivers StakingCollection.\n        self.toStakingCollectionCap.addNodeObject(\u003c- nodeStaker!, machineAccountInfo: machineAccountInfo)\n    }\n}",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "Address",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "311f4071dda8b17ac6cbc6f0a27e98bd426026825d3c68308903fead884e616e"
    },
    {
      "id": "SCO.14",
      "name": "Transfer Delegator",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n// Transfers a NodeDelegator object from an authorizers accoount\n// and adds the NodeDelegator to another accounts Staking Collection\n// identified by the to Address.\n\ntransaction(nodeID: String, delegatorID: UInt32, to: Address) {\n    let fromStakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        // The account to transfer the NodeDelegator object to must have a valid Staking Collection in order to receive the NodeDelegator.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(\"Destination account must have a Staking Collection set up.\")\n        }\n\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n\n        // Get the PublicAccount of the account to transfer the NodeDelegator to. \n        let toAccount = getAccount(to)\n\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.capabilities\n            .borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(FlowStakingCollection.StakingCollectionPublicPath)\n            ?? panic(\"Could not borrow a referamce to a StakingCollection in the receiver's account\")\n    }\n\n    execute {\n        // Remove the NodeDelegator from the authorizers StakingCollection.\n        let nodeDelegator \u003c- self.fromStakingCollectionRef.removeDelegator(nodeID: nodeID, delegatorID: delegatorID)\n\n        // Deposit the NodeDelegator to the receivers StakingCollection.\n        self.toStakingCollectionCap.addDelegatorObject(\u003c- nodeDelegator!)\n    }\n}",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": "42",
              "type": "UInt32"
            }
          ]
        },
        {
          "type": "Address",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "f9fa239cb78b3e07b8f8d56e173e2673b4b53aeb07d507a769c8d96eaf400b8d"
    },
    {
      "id": "SCO.15",
      "name": "Withdraw From Machine Account",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Request to withdraw tokens from the machine account\n/// The tokens are automatically deposited to the unlocked account vault\n\ntransaction(nodeID: String, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.withdrawFromMachineAccount(nodeID: nodeID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "fdd40862af04dc36dd0e9e727966c6f81dd6be8246b9c70afd18297aac9e86a8"
    },
    {
      "id": "SCO.16",
      "name": "Update Networking Address",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Changes the networking address for the specified node\n\ntransaction(nodeID: String, newAddress: String) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to a StakingCollection in the primary user's account\")\n    }\n\n    execute {\n        self.stakingCollectionRef.updateNetworkingAddress(nodeID: nodeID, newAddress: newAddress)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "flow-node.test:3569",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "3a68789d8cd56e6c7b064057045a56340746aac710db57700de2c33eb6610e5f"
    }
  ]
}