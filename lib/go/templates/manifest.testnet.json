{
  "network": "testnet",
  "templates": [
    {
      "id": "TH.01",
      "name": "Withdraw Unlocked FLOW",
      "source": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport LockedTokens from 0x95e019a17d0e23d7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.holderRef = acct.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow a reference to TokenHolder\")\n\n        self.vaultRef = acct.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow flow token vault ref\")\n    }\n\n    execute {\n        self.vaultRef.deposit(from: \u003c-self.holderRef.withdraw(amount: amount))\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "baca378532499da57d1df14da64f07ca5a07f177cc3f65c3fe605347256ee2d7"
    },
    {
      "id": "TH.02",
      "name": "Deposit Unlocked FLOW",
      "source": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport LockedTokens from 0x95e019a17d0e23d7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: \u0026LockedTokens.TokenHolder\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.holderRef = acct.storage.borrow\u003c\u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow a reference to TokenHolder\")\n\n        self.vaultRef = acct.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow flow token vault ref\")\n    }\n\n    execute {\n        self.holderRef.deposit(from: \u003c-self.vaultRef.withdraw(amount: amount))\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "fc2b44ac4249a0e0a5a26d63b6e9ad7afbc08f311ba281ec59bdb8554f620e80"
    },
    {
      "id": "TH.06",
      "name": "Register Node",
      "source": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LockedTokens from 0x95e019a17d0e23d7\nimport StakingProxy from 0x7aad92e5a0715d21\n\ntransaction(id: String, role: UInt8, networkingAddress: String, networkingKey: String, stakingKey: String, amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow ref to TokenHolder\")\n\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow flow token vault reference\")\n    }\n\n    execute {\n        let nodeInfo = StakingProxy.NodeInfo(\n          nodeID: id,\n          role: role,\n          networkingAddress: networkingAddress,\n          networkingKey: networkingKey,\n          stakingKey: stakingKey\n        )\n\n        let lockedBalance = self.holderRef.getLockedAccountBalance()\n\n        if amount \u003c= lockedBalance {\n\n            self.holderRef.createNodeStaker(nodeInfo: nodeInfo, amount: amount)\n\n        } else if ((amount - lockedBalance) \u003c= self.vaultRef.balance) {\n\n            self.holderRef.deposit(from: \u003c-self.vaultRef.withdraw(amount: amount - lockedBalance))\n\n            self.holderRef.createNodeStaker(nodeInfo: nodeInfo, amount: amount)\n\n        } else {\n            panic(\"Not enough tokens to stake!\")\n        }\n        \n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "role",
          "label": "Node Role",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingAddress",
          "label": "Networking Address",
          "sampleValues": [
            {
              "value": "flow-node.test:3569",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingKey",
          "label": "Networking Key",
          "sampleValues": [
            {
              "value": "1348307bc77c688e80049de9d081aa09755da33e6997605fa059db2144fc85e560cbe6f7da8d74b453f5916618cb8fd392c2db856f3e78221dc68db1b1d914e4",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "stakingKey",
          "label": "Staking Key",
          "sampleValues": [
            {
              "value": "9e9ae0d645fd5fd9050792e0b0daa82cc1686d9133afa0f81a784b375c42ae48567d1545e7a9e1965f2c1a32f73cf8575ebb7a967f6e4d104d2df78eb8be409135d12da0499b8a00771f642c1b9c49397f22b440439f036c3bdee82f5309dab3",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "af4a5bee843d4c45c4aaff6f4d047b86c00f13c53cf82d11d7fbe59245927914"
    },
    {
      "id": "TH.08",
      "name": "Stake New Locked FLOW",
      "source": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LockedTokens from 0x95e019a17d0e23d7\nimport StakingProxy from 0x7aad92e5a0715d21\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow flow token vault reference\")\n    }\n\n    execute {\n        let stakerProxy = self.holderRef.borrowStaker()\n\n        let lockedBalance = self.holderRef.getLockedAccountBalance()\n\n        if amount \u003c= lockedBalance {\n\n            stakerProxy.stakeNewTokens(amount: amount)\n\n        } else if ((amount - lockedBalance) \u003c= self.vaultRef.balance) {\n\n            self.holderRef.deposit(from: \u003c-self.vaultRef.withdraw(amount: amount - lockedBalance))\n\n            stakerProxy.stakeNewTokens(amount: amount)\n            \n        } else {\n            panic(\"Not enough tokens to stake!\")\n        }\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "0de2be29b4e3c0e672945f56e351bfa627f9b835bbebc24d69de3d6b914b0069"
    },
    {
      "id": "TH.09",
      "name": "Re-stake Unstaked FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport StakingProxy from 0x7aad92e5a0715d21\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n    }\n\n    execute {\n        let stakerProxy = self.holderRef.borrowStaker()\n\n        stakerProxy.stakeUnstakedTokens(amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "9b2eed9099742a2f002df6941117df03c68f113c62b6b27f0150cb00ef97f21f"
    },
    {
      "id": "TH.10",
      "name": "Re-stake Rewarded FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport StakingProxy from 0x7aad92e5a0715d21\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n    }\n\n    execute {\n        let stakerProxy = self.holderRef.borrowStaker()\n\n        stakerProxy.stakeRewardedTokens(amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "9c11d765716accd6ccccaa71826efd030eaec491cd288f12b3578c30406d02d7"
    },
    {
      "id": "TH.11",
      "name": "Request Unstake of FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport StakingProxy from 0x7aad92e5a0715d21\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n    }\n\n    execute {\n        let stakerProxy = self.holderRef.borrowStaker()\n\n        stakerProxy.requestUnstaking(amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "8a16eb440a6f2b0ba055c988195d18f1ac0ae87c9c47b6e3148295783a2edca0"
    },
    {
      "id": "TH.12",
      "name": "Unstake All FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport StakingProxy from 0x7aad92e5a0715d21\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction() {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n    }\n\n    execute {\n        let stakerProxy = self.holderRef.borrowStaker()\n\n        stakerProxy.unstakeAll()\n    }\n}\n",
      "arguments": [],
      "network": "testnet",
      "hash": "4e077e9ccdb995324823e202333ab3b31c52a773a3b33db070e9b1c3db8f24d4"
    },
    {
      "id": "TH.13",
      "name": "Withdraw Unstaked FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport StakingProxy from 0x7aad92e5a0715d21\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n    }\n\n    execute {\n        let stakerProxy = self.holderRef.borrowStaker()\n\n        stakerProxy.withdrawUnstakedTokens(amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "f28537c488e3967c414acdc8c853579d7cde872dbc867418b71b6708d24654c9"
    },
    {
      "id": "TH.14",
      "name": "Withdraw Rewarded FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n    let vaultRef: \u0026FlowToken.Vault\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n\n        self.vaultRef = account.storage.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow reference to FlowToken value\")\n    }\n\n    execute {\n        let stakerProxy = self.holderRef.borrowStaker()\n\n        stakerProxy.withdrawRewardedTokens(amount: amount)\n        self.vaultRef.deposit(from: \u003c-self.holderRef.withdraw(amount: amount))\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "a48cf76e38ef6818acfb35123a68b138caa66a1f27f2ee07c932ba74d6eca26e"
    },
    {
      "id": "TH.16",
      "name": "Register Operator Node",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport StakingProxy from 0x7aad92e5a0715d21\n\ntransaction(address: Address, id: String, amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations) \u0026LockedTokens.TokenHolder\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n    }\n\n    execute {\n        let nodeOperatorRef = getAccount(address).capabilities\n            .borrow\u003c\u0026StakingProxy.NodeStakerProxyHolder\u003e(\n                StakingProxy.NodeOperatorCapabilityPublicPath\n            )\n            ?? panic(\"Could not borrow node operator public capability\")\n\n        let nodeInfo = nodeOperatorRef.getNodeInfo(nodeID: id)\n            ?? panic(\"Couldn't get info for nodeID=\".concat(id))\n\n        self.holderRef.createNodeStaker(nodeInfo: nodeInfo, amount: amount)\n\n        let nodeStakerProxy = self.holderRef.borrowStaker()\n\n        nodeOperatorRef.addStakingProxy(nodeID: nodeInfo.id, proxy: nodeStakerProxy)\n    }\n}\n",
      "arguments": [
        {
          "type": "Address",
          "name": "address",
          "label": "Operator Address",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "9768a26085d718e69939f898b33cbe17cdcc8ef33d6c8d7ffda057fdced8324f"
    },
    {
      "id": "TH.17",
      "name": "Register Delegator",
      "source": "import FlowToken from 0x7e60df042a9c0868\nimport LockedTokens from 0x95e019a17d0e23d7\nimport FlowIDTableStaking from 0x9eca2b38b18b5dfe\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(id: String, amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"TokenHolder is not saved at specified path\")\n\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow flow token vault reference\")\n    }\n\n    execute {\n        let lockedBalance = self.holderRef.getLockedAccountBalance()\n\n        if amount \u003c= lockedBalance {\n\n            self.holderRef.createNodeDelegator(nodeID: id)\n\n            let stakerProxy = self.holderRef.borrowDelegator()\n\n            stakerProxy.delegateNewTokens(amount: amount - FlowIDTableStaking.getDelegatorMinimumStakeRequirement())\n\n        } else if ((amount - lockedBalance) \u003c= self.vaultRef.balance) {\n\n            self.holderRef.deposit(from: \u003c-self.vaultRef.withdraw(amount: amount - lockedBalance))\n\n            self.holderRef.createNodeDelegator(nodeID: id)\n\n            let stakerProxy = self.holderRef.borrowDelegator()\n\n            stakerProxy.delegateNewTokens(amount: amount - FlowIDTableStaking.getDelegatorMinimumStakeRequirement())\n\n        } else {\n            panic(\"Not enough tokens to stake!\")\n        }\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "b1ea953e7aed9e212f2f0e855e9122d3e1c2126c2b1ce318ac5d05c2bc3afbea"
    },
    {
      "id": "TH.19",
      "name": "Delegate New Locked FLOW",
      "source": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LockedTokens from 0x95e019a17d0e23d7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow flow token vault reference\")\n    }\n\n    execute {\n        let stakerProxy = self.holderRef.borrowDelegator()\n\n        let lockedBalance = self.holderRef.getLockedAccountBalance()\n\n        if amount \u003c= lockedBalance {\n\n            stakerProxy.delegateNewTokens(amount: amount)\n\n        } else if ((amount - lockedBalance) \u003c= self.vaultRef.balance) {\n\n            self.holderRef.deposit(from: \u003c-self.vaultRef.withdraw(amount: amount - lockedBalance))\n\n            stakerProxy.delegateNewTokens(amount: amount)\n        } else {\n            panic(\"Not enough tokens to stake!\")\n        }\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "f39299420444e21759568d0b263b71826f17e406e2c0270840db2a4dad3b33d7"
    },
    {
      "id": "TH.20",
      "name": "Re-delegate Unstaked FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n    let nodeDelegatorProxy: LockedTokens.LockedNodeDelegatorProxy\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"TokenHolder is not saved at specified path\")\n\n        self.nodeDelegatorProxy = holderRef.borrowDelegator()\n    }\n\n    execute {\n        self.nodeDelegatorProxy.delegateUnstakedTokens(amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "472c8c222dbeacd505e2db7fb20da0a709b45605e0a169ec8d4448c99fdfae95"
    },
    {
      "id": "TH.21",
      "name": "Re-delegate Rewarded FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n    let nodeDelegatorProxy: LockedTokens.LockedNodeDelegatorProxy\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"TokenHolder is not saved at specified path\")\n        \n        self.nodeDelegatorProxy = holderRef.borrowDelegator()\n    }\n\n    execute {\n        self.nodeDelegatorProxy.delegateRewardedTokens(amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "e618fbfde5089f5a0ab2fa05f908f65290296a404d23e9de1f0361c28e0e16fc"
    },
    {
      "id": "TH.22",
      "name": "Unstake Delegated FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n    let nodeDelegatorProxy: LockedTokens.LockedNodeDelegatorProxy\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"TokenHolder is not saved at specified path\")\n        \n        self.nodeDelegatorProxy = holderRef.borrowDelegator()\n    }\n\n    execute {\n        self.nodeDelegatorProxy.requestUnstaking(amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "d7bc6c6cd0ecf6a1e327ce1a8b95585fd624ca6066c896ae14b58c4be85fc10e"
    },
    {
      "id": "TH.23",
      "name": "Withdraw Unstaked FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n    let nodeDelegatorProxy: LockedTokens.LockedNodeDelegatorProxy\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"TokenHolder is not saved at specified path\")\n        \n        self.nodeDelegatorProxy = holderRef.borrowDelegator()\n    }\n\n    execute {\n        self.nodeDelegatorProxy.withdrawUnstakedTokens(amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "b60067583b91ab8be3e76619f93985b4c1cdc03bc2c310e79e8065f84e65b1c6"
    },
    {
      "id": "TH.24",
      "name": "Withdraw Rewarded FLOW",
      "source": "import LockedTokens from 0x95e019a17d0e23d7\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n    let vaultRef: \u0026FlowToken.Vault\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.holderRef = account.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Could not borrow reference to TokenHolder\")\n\n        self.vaultRef = account.storage.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow reference to FlowToken value\")\n    }\n\n    execute {\n        let delegatorProxy = self.holderRef.borrowDelegator()\n\n        delegatorProxy.withdrawRewardedTokens(amount: amount)\n        self.vaultRef.deposit(from: \u003c-self.holderRef.withdraw(amount: amount))\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "efc7c6866b01b89cb2f1436e525b273deeca5f8e765ec823889656d5f46ccd31"
    },
    {
      "id": "TH.25",
      "name": "Update Networking Address",
      "source": "import FlowIDTableStaking from 0x9eca2b38b18b5dfe\n\ntransaction(newAddress: String) {\n\n    // Local variable for a reference to the node object\n    let stakerRef: auth(FlowIDTableStaking.NodeOperator) \u0026FlowIDTableStaking.NodeStaker\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        // borrow a reference to the node object\n        self.stakerRef = acct.storage.borrow\u003cauth(FlowIDTableStaking.NodeOperator) \u0026FlowIDTableStaking.NodeStaker\u003e(from: FlowIDTableStaking.NodeStakerStoragePath)\n            ?? panic(\"Could not borrow reference to staking admin\")\n    }\n\n    execute {\n        self.stakerRef.updateNetworkingAddress(newAddress)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "flow-node.test:3569",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "876e4967516a8e8635b2f0818fcf25583c50105e41093d7ba62c3e408091cfb3"
    },
    {
      "id": "SCO.01",
      "name": "Setup Staking Collection",
      "source": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport FlowIDTableStaking from 0x9eca2b38b18b5dfe\nimport LockedTokens from 0x95e019a17d0e23d7\nimport FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// This transaction sets up an account to use a staking collection\n/// It will work regardless of whether they have a regular account, a two-account locked tokens setup,\n/// or staking objects stored in the unlocked account\n\ntransaction {\n    prepare(signer: auth(BorrowValue, Storage, Capabilities) \u0026Account) {\n\n        // If there isn't already a staking collection\n        if signer.storage.borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath) == nil {\n\n            // Create private capabilities for the token holder and unlocked vault\n            let lockedHolder = signer.capabilities.storage.issue\u003cauth(FungibleToken.Withdraw, LockedTokens.TokenOperations) \u0026LockedTokens.TokenHolder\u003e(LockedTokens.TokenHolderStoragePath)!\n            let flowToken = signer.capabilities.storage.issue\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(/storage/flowTokenVault)!\n\n            // Create a new Staking Collection and put it in storage\n            if lockedHolder.check() {\n                signer.storage.save(\n                    \u003c- FlowStakingCollection.createStakingCollection(\n                        unlockedVault: flowToken,\n                        tokenHolder: lockedHolder\n                    ),\n                    to: FlowStakingCollection.StakingCollectionStoragePath\n                )\n            } else {\n                signer.storage.save(\n                    \u003c- FlowStakingCollection.createStakingCollection(\n                        unlockedVault: flowToken,\n                        tokenHolder: nil\n                    ),\n                    to: FlowStakingCollection.StakingCollectionStoragePath\n                )\n            }\n\n            // Publish a capability to the created staking collection.\n            let stakingCollectionCap = signer.capabilities.storage.issue\u003c\u0026FlowStakingCollection.StakingCollection\u003e(\n                FlowStakingCollection.StakingCollectionStoragePath\n            )\n\n            signer.capabilities.publish(\n                stakingCollectionCap,\n                at: FlowStakingCollection.StakingCollectionPublicPath\n            )\n        }\n\n        // borrow a reference to the staking collection\n        let collectionRef = signer.storage.borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow staking collection reference\")\n\n        // If there is a node staker object in the account, put it in the staking collection\n        if signer.storage.borrow\u003c\u0026FlowIDTableStaking.NodeStaker\u003e(from: FlowIDTableStaking.NodeStakerStoragePath) != nil {\n            let node \u003c- signer.storage.load\u003c@FlowIDTableStaking.NodeStaker\u003e(from: FlowIDTableStaking.NodeStakerStoragePath)!\n            collectionRef.addNodeObject(\u003c-node, machineAccountInfo: nil)\n        }\n\n        // If there is a delegator object in the account, put it in the staking collection\n        if signer.storage.borrow\u003c\u0026FlowIDTableStaking.NodeDelegator\u003e(from: FlowIDTableStaking.DelegatorStoragePath) != nil {\n            let delegator \u003c- signer.storage.load\u003c@FlowIDTableStaking.NodeDelegator\u003e(from: FlowIDTableStaking.DelegatorStoragePath)!\n            collectionRef.addDelegatorObject(\u003c-delegator)\n        }\n    }\n}\n",
      "arguments": [],
      "network": "testnet",
      "hash": "861784e7ac135a9cfec90decdff2e53971a4d63135db77bcef3b273b710b1814"
    },
    {
      "id": "SCO.02",
      "name": "Register Delegator",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Registers a delegator in the staking collection resource\n/// for the specified nodeID and the amount of tokens to commit\n\ntransaction(id: String, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.registerDelegator(nodeID: id, amount: amount)      \n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "bbc61359628d6e0c30c1338bfba7a1dba424b866c3f5eb13388dfd3f633d6f02"
    },
    {
      "id": "SCO.03",
      "name": "Register Node",
      "source": "import Crypto\nimport FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Registers a delegator in the staking collection resource\n/// for the specified node information and the amount of tokens to commit\n\ntransaction(id: String,\n            role: UInt8,\n            networkingAddress: String,\n            networkingKey: String,\n            stakingKey: String,\n            amount: UFix64,\n            publicKeys: [Crypto.KeyListEntry]?) {\n\n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n\n        if let machineAccount = self.stakingCollectionRef.registerNode(\n            id: id,\n            role: role,\n            networkingAddress: networkingAddress,\n            networkingKey: networkingKey,\n            stakingKey: stakingKey,\n            amount: amount,\n            payer: account\n        ) {\n            if publicKeys == nil || publicKeys!.length == 0 {\n                panic(\"Cannot provide zero keys for the machine account\")\n            }\n            for key in publicKeys! {\n                machineAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)\n            }\n        }\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "role",
          "label": "Node Role",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingAddress",
          "label": "Networking Address",
          "sampleValues": [
            {
              "value": "flow-node.test:3569",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingKey",
          "label": "Networking Key",
          "sampleValues": [
            {
              "value": "1348307bc77c688e80049de9d081aa09755da33e6997605fa059db2144fc85e560cbe6f7da8d74b453f5916618cb8fd392c2db856f3e78221dc68db1b1d914e4",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "stakingKey",
          "label": "Staking Key",
          "sampleValues": [
            {
              "value": "9e9ae0d645fd5fd9050792e0b0daa82cc1686d9133afa0f81a784b375c42ae48567d1545e7a9e1965f2c1a32f73cf8575ebb7a967f6e4d104d2df78eb8be409135d12da0499b8a00771f642c1b9c49397f22b440439f036c3bdee82f5309dab3",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        },
        {
          "type": "[String]?",
          "name": "publicKeys",
          "label": "Public Keys",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": [],
                "type": "Array"
              },
              "type": "Optional"
            },
            {
              "value": {
                "value": [
                  {
                    "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                    "type": "String"
                  }
                ],
                "type": "Array"
              },
              "type": "Optional"
            },
            {
              "value": {
                "value": [
                  {
                    "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                    "type": "String"
                  },
                  {
                    "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                    "type": "String"
                  },
                  {
                    "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                    "type": "String"
                  }
                ],
                "type": "Array"
              },
              "type": "Optional"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "a98abb80fe8321b37c65d66972d27cc7da9fe7d5e575fe39f95a71a84e306d31"
    },
    {
      "id": "SCO.04",
      "name": "Create Machine Account",
      "source": "import Crypto\nimport FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Creates a machine account for a node that is already in the staking collection\n/// and adds public keys to the new account\n\ntransaction(nodeID: String, publicKeys: [Crypto.KeyListEntry]) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n\n        if let machineAccount = self.stakingCollectionRef.createMachineAccountForExistingNode(nodeID: nodeID, payer: account) {\n            if publicKeys == nil || publicKeys!.length == 0 {\n                panic(\"Cannot provide zero keys for the machine account\")\n            }\n            for key in publicKeys {\n                machineAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)\n            }\n        } else {\n            panic(\"Could not create a machine account for the node\")\n        }\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "[String]",
          "name": "publicKeys",
          "label": "Public Keys",
          "sampleValues": [
            {
              "value": [],
              "type": "Array"
            },
            {
              "value": [
                {
                  "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                  "type": "String"
                }
              ],
              "type": "Array"
            },
            {
              "value": [
                {
                  "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                  "type": "String"
                },
                {
                  "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                  "type": "String"
                },
                {
                  "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
                  "type": "String"
                }
              ],
              "type": "Array"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "f81cbe9d07980c4ac80257f63476fde140d08b0b040ed2ac8b3117067b95a19c"
    },
    {
      "id": "SCO.05",
      "name": "Request Unstaking",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Requests unstaking for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.requestUnstaking(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "0e868a8c719ebdf067198ec805e6d946b8d6b6ecc8780e141ecc6e7f1a23dcb4"
    },
    {
      "id": "SCO.06",
      "name": "Stake New Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Commits new tokens to stake for the specified node or delegator in the staking collection\n/// The tokens from the locked vault are used first, if it exists\n/// followed by the tokens from the unlocked vault\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.stakeNewTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "bd567a1cff4472091604f49eaa32bbb8b25dea7f4bdb7f7a4a40b1f9865d0169"
    },
    {
      "id": "SCO.07",
      "name": "Stake Rewarded Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Commits rewarded tokens to stake for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.stakeRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "39a656942f7255daaae8d414be2f9a55a7f1b2c0016d6506ccc60764dc2a5d24"
    },
    {
      "id": "SCO.08",
      "name": "Stake Unstaked Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Commits unstaked tokens to stake for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.stakeUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "8aa46983fcdd33905720c59b280743817f9153fb04252928ffef2b672e4b5c93"
    },
    {
      "id": "SCO.09",
      "name": "Unstake All",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Requests to unstake ALL tokens for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.unstakeAll(nodeID: nodeID)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "20f46888d167b973bb903248dbbcef45d4529bc41b7f7e3a03148bd909988c60"
    },
    {
      "id": "SCO.10",
      "name": "Withdraw Rewarded Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Request to withdraw rewarded tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.withdrawRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            },
            {
              "value": null,
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "6dc4302bdebb2ce5c154fe7726f00d38a9cef741995494eb925bc793123d44ed"
    },
    {
      "id": "SCO.11",
      "name": "Withdraw Unstaked Tokens",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Request to withdraw unstaked tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault if it is there\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.withdrawUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "fe68dea0de693f29fdc7c46ed712f4c2c11b950d23edea0fdb767e04f71d6f34"
    },
    {
      "id": "SCO.12",
      "name": "Close Stake",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n// Closes out a staking object in the staking collection\n// This does not remove the record from the identity table,\n// but it does mean that the account that closes it cannot ever access it again\n\ntransaction(nodeID: String, delegatorID: UInt32?) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.closeStake(nodeID: nodeID, delegatorID: delegatorID)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            },
            {
              "value": null,
              "type": "Optional"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "b488275765d1c1166028a072f381d7dd15aadd30805e3b9b8ecdb9e8cefde91c"
    },
    {
      "id": "SCO.13",
      "name": "Transfer Node",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n// Transfers a NodeStaker object from an authorizers accoount\n// and adds the NodeStaker to another accounts Staking Collection\n// identified by the to Address.\n\ntransaction(nodeID: String, to: Address) {\n    let fromStakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        // The account to transfer the NodeStaker object to must have a valid Staking Collection in order to receive the NodeStaker.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(\"Destination account must have a Staking Collection set up.\")\n        }\n\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n\n        // Get the PublicAccount of the account to transfer the NodeStaker to. \n        let toAccount = getAccount(to)\n\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.capabilities\n            .borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(FlowStakingCollection.StakingCollectionPublicPath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n\n        let machineAccountInfo = self.fromStakingCollectionRef.getMachineAccounts()[nodeID]\n            ?? panic(\"Could not get machine account info for the specified node ID\")\n\n        // Remove the NodeStaker from the authorizers StakingCollection.\n        let nodeStaker \u003c- self.fromStakingCollectionRef.removeNode(nodeID: nodeID)\n\n        // Deposit the NodeStaker to the receivers StakingCollection.\n        self.toStakingCollectionCap.addNodeObject(\u003c- nodeStaker!, machineAccountInfo: machineAccountInfo)\n    }\n}",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "Address",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "57859903fde52b65b166f1f8fee9c18d6c7260739a8753a79ef014b02f0b2fab"
    },
    {
      "id": "SCO.14",
      "name": "Transfer Delegator",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n// Transfers a NodeDelegator object from an authorizers accoount\n// and adds the NodeDelegator to another accounts Staking Collection\n// identified by the to Address.\n\ntransaction(nodeID: String, delegatorID: UInt32, to: Address) {\n    let fromStakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        // The account to transfer the NodeDelegator object to must have a valid Staking Collection in order to receive the NodeDelegator.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(\"Destination account must have a Staking Collection set up.\")\n        }\n\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n\n        // Get the PublicAccount of the account to transfer the NodeDelegator to. \n        let toAccount = getAccount(to)\n\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.capabilities\n            .borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(FlowStakingCollection.StakingCollectionPublicPath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        // Remove the NodeDelegator from the authorizers StakingCollection.\n        let nodeDelegator \u003c- self.fromStakingCollectionRef.removeDelegator(nodeID: nodeID, delegatorID: delegatorID)\n\n        // Deposit the NodeDelegator to the receivers StakingCollection.\n        self.toStakingCollectionCap.addDelegatorObject(\u003c- nodeDelegator!)\n    }\n}",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": "42",
              "type": "UInt32"
            }
          ]
        },
        {
          "type": "Address",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "0x8c5303eaa26202d6",
              "type": "Address"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "770b1a66b462e46e2cfaedaebedfddc94fe4e3a877b7e73f73b444f802c8c578"
    },
    {
      "id": "SCO.15",
      "name": "Withdraw From Machine Account",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Request to withdraw tokens from the machine account\n/// The tokens are automatically deposited to the unlocked account vault\n\ntransaction(nodeID: String, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.withdrawFromMachineAccount(nodeID: nodeID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "ffc0618f599477283475121bb54789e9c7b860fa74d0bcbfb90d8551d4adba57"
    },
    {
      "id": "SCO.16",
      "name": "Update Networking Address",
      "source": "import FlowStakingCollection from 0x95e019a17d0e23d7\n\n/// Changes the networking address for the specified node\n\ntransaction(nodeID: String, newAddress: String) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n\n    execute {\n        self.stakingCollectionRef.updateNetworkingAddress(nodeID: nodeID, newAddress: newAddress)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "flow-node.test:3569",
              "type": "String"
            }
          ]
        }
      ],
      "network": "testnet",
      "hash": "0b8b6fbdd32ebcf5adf1a431e88bd8ac31bde3a64443a735f3ed597ebca48ae6"
    }
  ]
}