{
  "network": "mainnet",
  "templates": [
    {
      "id": "FA.01",
      "name": "Create Account",
      "source": "import Crypto\n\ntransaction(key: String, signatureAlgorithm: UInt8, hashAlgorithm: UInt8) {\n\tprepare(signer: auth(BorrowValue, Storage) \u0026Account) {\n\t\tpre {\n\t\t\tsignatureAlgorithm == 1 || signatureAlgorithm == 2:\n                \"Cannot add Key: Must provide a signature algorithm raw value that corresponds to \"\n                .concat(\"one of the available signature algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(signatureAlgorithm.toString())\n                .concat(\" but the options are either 1 (ECDSA_P256) or 2 (ECDSA_secp256k1).\")\n\t\t\thashAlgorithm == 1 || hashAlgorithm == 3:\n                \"Cannot add Key: Must provide a hash algorithm raw value that corresponds to \"\n                .concat(\"one of of the available hash algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(hashAlgorithm.toString())\n                .concat(\" but the options are either 1 (SHA2_256) or 3 (SHA3_256).\")\n\t\t}\n\n\t\tlet publicKey = PublicKey(\n\t\t\tpublicKey: key.decodeHex(),\n\t\t\tsignatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!\n\t\t)\n\n\t\tlet account = Account(payer: signer)\n\n\t\taccount.keys.add(publicKey: publicKey, hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!, weight: 1000.0)\n\t}\n}",
      "arguments": [
        {
          "type": "String",
          "name": "key",
          "label": "Public Key",
          "sampleValues": [
            {
              "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "signatureAlgorithm",
          "label": "Raw Value for Signature Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "hashAlgorithm",
          "label": "Raw Value for Hash Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "9e46752d27947cc85e5fb62f4deecb12bd7b2a721211ef944acf528bd648dcd7"
    },
    {
      "id": "FA.02",
      "name": "Add Key",
      "source": "import Crypto\n\ntransaction(key: String, signatureAlgorithm: UInt8, hashAlgorithm: UInt8, weight: UFix64) {\n\n\tprepare(signer: auth(AddKey) \u0026Account) {\n\t\tpre {\n\t\t\tsignatureAlgorithm == 1 || signatureAlgorithm == 2:\n                \"Cannot add Key: Must provide a signature algorithm raw value that corresponds to \"\n                .concat(\"one of the available signature algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(signatureAlgorithm.toString())\n                .concat(\" but the options are either 1 (ECDSA_P256) or 2 (ECDSA_secp256k1).\")\n\t\t\thashAlgorithm == 1 || hashAlgorithm == 3:\n                \"Cannot add Key: Must provide a hash algorithm raw value that corresponds to \"\n                .concat(\"one of of the available hash algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(hashAlgorithm.toString())\n                .concat(\" but the options are either 1 (SHA2_256) or 3 (SHA3_256).\")\n\t\t\tweight \u003c= 1000.0:\n                \"Cannot add Key: The key weight must be between 0 and 1000.\"\n                .concat(\" You provided \").concat(weight.toString()).concat(\" which is invalid.\")\n\t\t}\n\t\t\n\t\tlet publicKey = PublicKey(\n\t\t\tpublicKey: key.decodeHex(),\n\t\t\tsignatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!\n\t\t)\n\n\t\tsigner.keys.add(publicKey: publicKey, hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!, weight: weight)\n\t}\n}",
      "arguments": [
        {
          "type": "String",
          "name": "key",
          "label": "Public Key",
          "sampleValues": [
            {
              "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "signatureAlgorithm",
          "label": "Raw Value for Signature Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "hashAlgorithm",
          "label": "Raw Value for Hash Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "weight",
          "label": "Key Weight",
          "sampleValues": [
            {
              "value": "1000.00000000",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "5b26465efc98fbc2a41c2c3c170eb5d74886745b34571d6041611d268a3f9028"
    },
    {
      "id": "FA.03",
      "name": "Remove Key",
      "source": "transaction(keyIndex: Int) {\n\tprepare(signer: auth(RevokeKey) \u0026Account) {\n\t\tif let key = signer.keys.get(keyIndex: keyIndex) {\n\t\t\tsigner.keys.revoke(keyIndex: keyIndex)\n\t\t} else {\n            panic(\"Cannot revoke key: No key with the index \"\n                  .concat(keyIndex.toString())\n                  .concat(\" exists on the authorizer's account.\"))\n\t\t}\n\t}\n}",
      "arguments": [
        {
          "type": "Int",
          "name": "keyIndex",
          "label": "Key Index",
          "sampleValues": [
            {
              "value": "1",
              "type": "Int"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "69409133294a24bc167375f47043604676b7fdf1dde9396540c13ff540aa9288"
    },
    {
      "id": "FT.01",
      "name": "Setup Fungible Token Vault",
      "source": "import FungibleToken from 0xf233dcee88fe0abe\nimport FungibleTokenMetadataViews from 0xf233dcee88fe0abe\n\n#interaction (\n  version: \"1.0.0\",\n\ttitle: \"Generic FT Transfer with Contract Address and Name\",\n\tdescription: \"Transfer any Fungible Token by providing the contract address and name\",\n\tlanguage: \"en-US\",\n)\n\n/// This transaction is what an account would run\n/// to set itself up to manage fungible tokens. This function\n/// uses views to know where to set up the vault\n/// in storage and to create the empty vault.\n///\n/// @param contractAddress: The address of the contract\n///        that defines the tokens to initialize\n/// @param contractName: The name of the contract\n///        that defines the tokens to initialize. Ex: \"FlowToken\"\n\ntransaction(contractAddress: Address, contractName: String) {\n\n    prepare(signer: auth(SaveValue, Capabilities) \u0026Account) {\n        // Borrow a reference to the vault stored on the passed account at the passed publicPath\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow\u003c\u0026{FungibleToken}\u003e(name: contractName)\n                ?? panic(\"Could not borrow FungibleToken reference to the contract. Make sure the provided contract name (\"\n                          .concat(contractName).concat(\") and address (\").concat(contractAddress.toString()).concat(\") are correct!\"))\n\n        // Use that reference to retrieve the FTView \n        let ftVaultData = resolverRef.resolveContractView(resourceType: nil, viewType: Type\u003cFungibleTokenMetadataViews.FTVaultData\u003e()) as! FungibleTokenMetadataViews.FTVaultData?\n            ?? panic(\"Could not resolve FTVaultData view. The \".concat(contractName)\n                .concat(\" contract needs to implement the FTVaultData Metadata view in order to execute this transaction.\"))\n\n        // Create a new empty vault using the createEmptyVault function inside the FTVaultData\n        let emptyVault \u003c-ftVaultData.createEmptyVault()\n\n        // Save it to the account\n        signer.storage.save(\u003c-emptyVault, to: ftVaultData.storagePath)\n        \n        // Create a public capability for the vault which includes the .Resolver interface\n        let vaultCap = signer.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(ftVaultData.storagePath)\n        signer.capabilities.publish(vaultCap, at: ftVaultData.metadataPath)\n\n        // Create a public capability for the vault exposing the receiver interface\n        let receiverCap = signer.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(ftVaultData.storagePath)\n        signer.capabilities.publish(receiverCap, at: ftVaultData.receiverPath)\n\n    }\n}\n ",
      "arguments": [
        {
          "type": "Address",
          "name": "contractAddress",
          "label": "FT Contract Address",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "contractName",
          "label": "FT Contract Name",
          "sampleValues": [
            {
              "value": "FiatToken",
              "type": "String"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "66a0b8f3c7da3cc8a3e5176d5b6d208f2cf9492d5c79db1c64ce0add436fcbbc"
    },
    {
      "id": "FT.02",
      "name": "Transfer Fungible Token with Paths",
      "source": "import FungibleToken from 0xf233dcee88fe0abe\n\n#interaction (\n  version: \"1.0.0\",\n\ttitle: \"Generic FT Transfer with Paths\",\n\tdescription: \"Transfer any Fungible Token by providing the paths for the source Vault and destination Vault\",\n\tlanguage: \"en-US\",\n)\n\n/// Can pass in any storage path and receiver path identifier instead of just the default.\n/// This lets you choose the token you want to send as well the capability you want to send it to.\n///\n/// Any token path can be passed as an argument here, so wallets should\n/// should check argument values to make sure the intended token path is passed in\n///\n/// @param amount: The amount of tokens to transfer\n/// @param to: The address to transfer the tokens to\n/// @param senderPathIdentifier: The string identifier of the storage path\n///        where the tokens should be withdrawn from\n/// @param receiverPathIdentifier: The string identifier of the public path\n///        where the tokens should be deposited to\n///\ntransaction(amount: UFix64, to: Address, senderPathIdentifier: String, receiverPathIdentifier: String) {\n\n    // The Vault resource that holds the tokens that are being transferred\n    let tempVault: @{FungibleToken.Vault}\n\n    prepare(signer: auth(BorrowValue) \u0026Account) {\n\n        let storagePath = StoragePath(identifier: senderPathIdentifier)\n            ?? panic(\"Could not construct a storage path from the provided path identifier string.\")\n\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Provider}\u003e(from: storagePath)\n\t\t\t?? panic(\"The signer does not store a FungibleToken.Provider object at the path \"\n                .concat(storagePath.toString())\n                .concat(\". The signer must initialize their account with this object first!\"))\n\n        self.tempVault \u003c- vaultRef.withdraw(amount: amount)\n\n        assert(\n            self.tempVault.balance == amount,\n            message: \"Error: The Vault to transfer does not have the balance that was requested!\"\n        )\n    }\n\n    execute {\n        let publicPath = PublicPath(identifier: receiverPathIdentifier)\n            ?? panic(\"Could not construct a public path from the provided path identifier string\")\n\n        let recipient = getAccount(to)\n        let receiverRef = recipient.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(publicPath)\n            ?? panic(\"Could not borrow a Receiver reference to the FungibleToken Vault in account \"\n                .concat(to.toString()).concat(\" at path \").concat(publicPath.toString())\n                .concat(\". Make sure you are sending to an address that has \")\n                .concat(\"a FungibleToken Vault set up properly at the specified path.\"))\n\n        // Transfer tokens from the signer's stored vault to the receiver capability\n        receiverRef.deposit(from: \u003c-self.tempVault)\n    }\n}",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        },
        {
          "type": "Address",
          "name": "to",
          "label": "Recipient",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "senderPathIdentifier",
          "label": "Sender's Collection Path Identifier",
          "sampleValues": [
            {
              "value": "flowTokenVault",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "receiverPathIdentifier",
          "label": "Recipient's Receiver Path Identifier",
          "sampleValues": [
            {
              "value": "flowTokenReceiver",
              "type": "String"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "4c5f45fb6b2c2fbd3279d9dd56e044cb95be908b2dedbe30c2b444d50575df7f"
    },
    {
      "id": "FT.03",
      "name": "Transfer Fungible Token with Address",
      "source": "import FungibleToken from 0xf233dcee88fe0abe\nimport FungibleTokenMetadataViews from 0xf233dcee88fe0abe\n\n#interaction (\n  version: \"1.0.0\",\n\ttitle: \"Generic FT Transfer with Contract Address and Name\",\n\tdescription: \"Transfer any Fungible Token by providing the contract address and name\",\n\tlanguage: \"en-US\",\n)\n\n/// Can pass in any contract address and name to transfer a token from that contract\n/// This lets you choose the token you want to send\n///\n/// Any contract can be chosen here, so wallets should check argument values\n/// to make sure the intended token contract name and address is passed in\n/// Contracts that are used must implement the FTVaultData Metadata View\n///\n/// Note: This transaction only will work for Fungible Tokens that\n///       have their token's resource name set as \"Vault\".\n///       Tokens with other names will need to use a different transaction\n///       that additionally specifies the identifier\n///\n/// @param amount: The amount of tokens to transfer\n/// @param to: The address to transfer the tokens to\n/// @param contractAddress: The address of the contract that defines the tokens being transferred\n/// @param contractName: The name of the contract that defines the tokens being transferred. Ex: \"FlowToken\"\n///\ntransaction(amount: UFix64, to: Address, contractAddress: Address, contractName: String) {\n\n    // The Vault resource that holds the tokens that are being transferred\n    let tempVault: @{FungibleToken.Vault}\n\n    // FTVaultData struct to get paths from\n    let vaultData: FungibleTokenMetadataViews.FTVaultData\n\n    prepare(signer: auth(BorrowValue) \u0026Account) {\n\n        // Borrow a reference to the vault stored on the passed account at the passed publicPath\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow\u003c\u0026{FungibleToken}\u003e(name: contractName)\n                ?? panic(\"Could not borrow FungibleToken reference to the contract. Make sure the provided contract name (\"\n                          .concat(contractName).concat(\") and address (\").concat(contractAddress.toString()).concat(\") are correct!\"))\n\n        // Use that reference to retrieve the FTView \n        self.vaultData = resolverRef.resolveContractView(resourceType: nil, viewType: Type\u003cFungibleTokenMetadataViews.FTVaultData\u003e()) as! FungibleTokenMetadataViews.FTVaultData?\n            ?? panic(\"Could not resolve FTVaultData view. The \".concat(contractName)\n                .concat(\" contract needs to implement the FTVaultData Metadata view in order to execute this transaction.\"))\n\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Provider}\u003e(from: self.vaultData.storagePath)\n\t\t\t?? panic(\"The signer does not store a FungibleToken.Provider object at the path \"\n                .concat(self.vaultData.storagePath.toString()).concat(\"For the \").concat(contractName)\n                .concat(\" contract at address \").concat(contractAddress.toString())\n                .concat(\". The signer must initialize their account with this object first!\"))\n\n        self.tempVault \u003c- vaultRef.withdraw(amount: amount)\n\n        // Get the string representation of the address without the 0x\n        var addressString = contractAddress.toString()\n        if addressString.length == 18 {\n            addressString = addressString.slice(from: 2, upTo: 18)\n        }\n        let typeString: String = \"A.\".concat(addressString).concat(\".\").concat(contractName).concat(\".Vault\")\n        let type = CompositeType(typeString)\n        assert(\n            type != nil,\n            message: \"Could not create a type out of the contract name and address!\"\n        )\n\n        assert(\n            self.tempVault.getType() == type!,\n            message: \"The Vault that was withdrawn to transfer is not the type that was requested!\"\n        )\n    }\n\n    execute {\n        let recipient = getAccount(to)\n        let receiverRef = recipient.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(self.vaultData.receiverPath)\n            ?? panic(\"Could not borrow a Receiver reference to the FungibleToken Vault in account \"\n                .concat(to.toString()).concat(\" at path \").concat(self.vaultData.receiverPath.toString())\n                .concat(\". Make sure you are sending to an address that has \")\n                .concat(\"a FungibleToken Vault set up properly at the specified path.\"))\n\n        // Transfer tokens from the signer's stored vault to the receiver capability\n        receiverRef.deposit(from: \u003c-self.tempVault)\n    }\n}",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        },
        {
          "type": "Address",
          "name": "to",
          "label": "Recipient",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        },
        {
          "type": "Address",
          "name": "contractAddress",
          "label": "FT Contract Address",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "contractName",
          "label": "FT Contract Name",
          "sampleValues": [
            {
              "value": "FiatToken",
              "type": "String"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "91672738d5ea84c59c78096da25179186288ae2de2116b7f8928d594695bebf6"
    },
    {
      "id": "NFT.01",
      "name": "Setup NFT Collection",
      "source": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n#interaction (\n  version: \"1.0.0\",\n\ttitle: \"Generic FT Transfer with Contract Address and Name\",\n\tdescription: \"Transfer any Fungible Token by providing the contract address and name\",\n\tlanguage: \"en-US\",\n)\n\n/// This transaction is what an account would run\n/// to set itself up to receive NFTs. This function\n/// uses views to know where to set up the collection\n/// in storage and to create the empty collection.\n///\n/// @param contractAddress: The address of the contract that defines the token being initialized\n/// @param contractName: The name of the contract that defines the token being initialized. Ex: \"ExampleNFT\"\n\ntransaction(contractAddress: Address, contractName: String) {\n\n    prepare(signer: auth(IssueStorageCapabilityController, PublishCapability, SaveValue) \u0026Account) {\n        // Borrow a reference to the nft contract deployed to the passed account\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow\u003c\u0026{NonFungibleToken}\u003e(name: contractName)\n                ?? panic(\"Could not borrow NonFungibleToken reference to the contract. Make sure the provided contract name (\"\n                         .concat(contractName).concat(\") and address (\").concat(contractAddress.toString()).concat(\") are correct!\"))\n\n        // Use that reference to retrieve the NFTCollectionData view \n        let collectionData = resolverRef.resolveContractView(resourceType: nil, viewType: Type\u003cMetadataViews.NFTCollectionData\u003e()) as! MetadataViews.NFTCollectionData?\n            ?? panic(\"Could not resolve NFTCollectionData view. The \".concat(contractName).concat(\" contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction\"))\n\n        // Create a new empty collections\n        let emptyCollection \u003c- collectionData.createEmptyCollection()\n\n        // save it to the account\n        signer.storage.save(\u003c-emptyCollection, to: collectionData.storagePath)\n\n        // create a public capability for the collection\n        let collectionCap = signer.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(\n                collectionData.storagePath\n            )\n        signer.capabilities.publish(collectionCap, at: collectionData.publicPath)\n    }\n}\n",
      "arguments": [
        {
          "type": "Address",
          "name": "contractAddress",
          "label": "NFT Contract Address",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "contractName",
          "label": "NFT Contract Name",
          "sampleValues": [
            {
              "value": "TopShot",
              "type": "String"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "79f5eda23f53e9b58472907c5dedaf536e3f9b777aa302a079a7a4763982d618"
    },
    {
      "id": "NFT.02",
      "name": "Transfer NFT with Paths",
      "source": "import NonFungibleToken from 0x1d7e57aa55817448\n\n#interaction (\n  version: \"1.0.0\",\n\ttitle: \"Generic NFT Transfer with Paths\",\n\tdescription: \"Transfer any Non-Fungible Token by providing the paths for the source Collection and destination Collection\",\n\tlanguage: \"en-US\",\n)\n\n/// Can pass in any storage path and receiver path instead of just the default.\n/// This lets you choose the token you want to send as well the capability you want to send it to.\n///\n/// Any token path can be passed as an argument here, so wallets should\n/// should check argument values to make sure the intended token path is passed in\n///\n/// @param to: The address to transfer the token to\n/// @param id: The id of the token to transfer\n/// @param senderPathIdentifier: The string identifier of the storage path\n///        where the token should be withdrawn from\n/// @param receiverPathIdentifier: The string identifier of the public path\n///        where the token should be deposited to\n///\ntransaction(to: Address, id: UInt64, senderPathIdentifier: String, receiverPathIdentifier: String) {\n\n    // The NFT resource to be transferred\n    let tempNFT: @{NonFungibleToken.NFT}\n\n    prepare(signer: auth(BorrowValue) \u0026Account) {\n\n        let storagePath = StoragePath(identifier: senderPathIdentifier)\n            ?? panic(\"Could not construct a storage path from the provided path identifier string\")\n\n        // borrow a reference to the signer's NFT collection\n        let withdrawRef = signer.storage.borrow\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(\n                from: storagePath\n            ) ?? panic(\"The signer does not store a NonFungibleToken Collection object at the path \"\n                        .concat(storagePath.toString())\n                        .concat(\"The signer must initialize their account with this collection first!\"))\n\n        self.tempNFT \u003c- withdrawRef.withdraw(withdrawID: id)\n    }\n\n    execute {\n        let publicPath = PublicPath(identifier: receiverPathIdentifier)\n            ?? panic(\"Could not construct a public path from the provided path identifier string \\\"\"\n                      .concat(receiverPathIdentifier)\n                      .concat(\"\\\".\"))\n\n        // get the recipients public account object\n        let recipient = getAccount(to)\n\n        // borrow a public reference to the receivers collection\n        let receiverRef = recipient.capabilities.borrow\u003c\u0026{NonFungibleToken.Receiver}\u003e(publicPath)\n            ?? panic(\"The recipient does not have a NonFungibleToken Receiver at \"\n                        .concat(publicPath.toString())\n                        .concat(\" that is capable of receiving a NFT.\")\n                        .concat(\"The recipient must initialize their account with this collection and receiver first!\"))\n\n        // Deposit the NFT to the receiver\n        receiverRef.deposit(token: \u003c-self.tempNFT)\n    }\n}",
      "arguments": [
        {
          "type": "Address",
          "name": "to",
          "label": "Recipient",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        },
        {
          "type": "UInt64",
          "name": "id",
          "label": "NFT ID to Transfer",
          "sampleValues": [
            {
              "value": "10",
              "type": "UInt64"
            }
          ]
        },
        {
          "type": "String",
          "name": "senderPathIdentifier",
          "label": "Sender's Collection Path Identifier",
          "sampleValues": [
            {
              "value": "flowTokenVault",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "receiverPathIdentifier",
          "label": "Recipient's Receiver Path Identifier",
          "sampleValues": [
            {
              "value": "flowTokenReceiver",
              "type": "String"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "5f050afb9d275119e22546f860aef0168f1057823bb4777c2024aef7c6ac1cc7"
    },
    {
      "id": "NFT.03",
      "name": "Transfer NFT with Address",
      "source": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n#interaction (\n  version: \"1.0.0\",\n\ttitle: \"Generic NFT Transfer with Contract Address and Name\",\n\tdescription: \"Transfer any Non-Fungible Token by providing the contract address and name\",\n\tlanguage: \"en-US\",\n)\n\n/// Can pass in any contract address and name\n/// This lets you choose the token you want to send because\n/// the transaction gets the metadata from the provided contract.\n///\n/// @param to: The address to transfer the token to\n/// @param id: The id of token to transfer\n/// @param contractAddress: The address of the contract that defines the token being transferred\n/// @param contractName: The name of the contract that defines the token being transferred. Ex: \"ExampleNFT\"\n///\n/// This transaction only works with NFTs that have the type name \"NFT\"\n/// A different transaction is required for NFTs with a different type name\n///\ntransaction(to: Address, id: UInt64, contractAddress: Address, contractName: String) {\n\n    // The NFT resource to be transferred\n    let tempNFT: @{NonFungibleToken.NFT}\n\n    // NFTCollectionData struct to get paths from\n    let collectionData: MetadataViews.NFTCollectionData\n\n    prepare(signer: auth(BorrowValue) \u0026Account) {\n\n        // Borrow a reference to the nft contract deployed to the passed account\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow\u003c\u0026{NonFungibleToken}\u003e(name: contractName)\n                ?? panic(\"Could not borrow NonFungibleToken reference to the contract. Make sure the provided contract name (\"\n                          .concat(contractName).concat(\") and address (\").concat(contractAddress.toString()).concat(\") are correct!\"))\n\n        // Use that reference to retrieve the NFTCollectionData view \n        self.collectionData = resolverRef.resolveContractView(resourceType: nil, viewType: Type\u003cMetadataViews.NFTCollectionData\u003e()) as! MetadataViews.NFTCollectionData?\n            ?? panic(\"Could not resolve NFTCollectionData view. The \".concat(contractName).concat(\" contract needs to implement the NFTCollectionData Metadata view in order to execute this transaction\"))\n\n\n        // borrow a reference to the signer's NFT collection\n        let withdrawRef = signer.storage.borrow\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(\n                from: self.collectionData.storagePath\n            ) ?? panic(\"The signer does not store a \"\n                        .concat(contractName)\n                        .concat(\" Collection object at the path \")\n                        .concat(self.collectionData.storagePath.toString())\n                        .concat(\". The signer must initialize their account with this collection first!\"))\n\n        self.tempNFT \u003c- withdrawRef.withdraw(withdrawID: id)\n\n        // Get the string representation of the address without the 0x\n        var addressString = contractAddress.toString()\n        if addressString.length == 18 {\n            addressString = addressString.slice(from: 2, upTo: 18)\n        }\n        let typeString: String = \"A.\".concat(addressString).concat(\".\").concat(contractName).concat(\".NFT\")\n        let type = CompositeType(typeString)\n        assert(\n            type != nil,\n            message: \"Could not create a type out of the contract name \"\n                      .concat(contractName)\n                      .concat(\" and address \")\n                      .concat(addressString)\n                      .concat(\"!\")\n        )\n\n        assert(\n            self.tempNFT.getType() == type!,\n            message: \"The NFT that was withdrawn to transfer is not the type that was requested \u003c\"\n                     .concat(typeString).concat(\"\u003e.\")\n        )\n    }\n\n    execute {\n        // get the recipients public account object\n        let recipient = getAccount(to)\n\n        // borrow a public reference to the receivers collection\n        let receiverRef = recipient.capabilities.borrow\u003c\u0026{NonFungibleToken.Receiver}\u003e(self.collectionData.publicPath)\n            ?? panic(\"The recipient does not have a NonFungibleToken Receiver at \"\n                        .concat(self.collectionData.publicPath.toString())\n                        .concat(\" that is capable of receiving a \")\n                        .concat(contractName)\n                        .concat(\" NFT.\")\n                        .concat(\"The recipient must initialize their account with this collection and receiver first!\"))\n\n        // Deposit the NFT to the receiver\n        receiverRef.deposit(token: \u003c-self.tempNFT)\n    }\n}",
      "arguments": [
        {
          "type": "Address",
          "name": "to",
          "label": "Recipient",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        },
        {
          "type": "UInt64",
          "name": "id",
          "label": "NFT ID to Transfer",
          "sampleValues": [
            {
              "value": "10",
              "type": "UInt64"
            }
          ]
        },
        {
          "type": "Address",
          "name": "contractAddress",
          "label": "NFT Contract Address",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        },
        {
          "type": "String",
          "name": "contractName",
          "label": "NFT Contract Name",
          "sampleValues": [
            {
              "value": "TopShot",
              "type": "String"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "e214e8ba77ee79a8acfbea11a2255378e2123a60d1bc4981277aec1c9b41b41b"
    },
    {
      "id": "TH.01",
      "name": "Withdraw Unlocked FLOW",
      "source": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport LockedTokens from 0x8d0e87b65159ae63\n\ntransaction(amount: UFix64) {\n\n    let holderRef: auth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.holderRef = acct.storage.borrow\u003cauth(LockedTokens.TokenOperations, FungibleToken.Withdraw) \u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Cannot withdraw locked tokens! The signer of the transaction \"\n                    .concat(\"does not have an associated locked account, \")\n                    .concat(\"so there are no locked tokens to withdraw.\"))\n\n        self.vaultRef = acct.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"The signer does not store a FlowToken Vault object at the path \"\n                    .concat(\"/storage/flowTokenVault. \")\n                    .concat(\"The signer must initialize their account with this vault first!\"))\n    }\n\n    execute {\n        self.vaultRef.deposit(from: \u003c-self.holderRef.withdraw(amount: amount))\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "db6fc54bee86ff8933fd39d53bda1bd713c8a3c8d6d57be9cb415152d1d4c6f4"
    },
    {
      "id": "TH.02",
      "name": "Deposit Unlocked FLOW",
      "source": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport LockedTokens from 0x8d0e87b65159ae63\n\ntransaction(amount: UFix64) {\n\n    let holderRef: \u0026LockedTokens.TokenHolder\n    let vaultRef: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.holderRef = acct.storage.borrow\u003c\u0026LockedTokens.TokenHolder\u003e(from: LockedTokens.TokenHolderStoragePath)\n            ?? panic(\"Cannot deposit tokens to a locked account! The signer of the transaction \"\n                    .concat(\"does not have an associated locked account, \")\n                    .concat(\"so there is nowhere to deposit the tokens.\"))\n\n        self.vaultRef = acct.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"The signer does not store a FlowToken Vault object at the path \"\n                    .concat(\"/storage/flowTokenVault. \")\n                    .concat(\"The signer must initialize their account with this vault first!\"))\n    }\n\n    execute {\n        self.holderRef.deposit(from: \u003c-self.vaultRef.withdraw(amount: amount))\n    }\n}\n",
      "arguments": [
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "73e043f0c811e990d4f6f125c3f80ff015f5e0a972a75c02ddb61501d83a367f"
    },
    {
      "id": "SCO.01",
      "name": "Setup Staking Collection",
      "source": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport FlowIDTableStaking from 0x8624b52f9ddcd04a\nimport LockedTokens from 0x8d0e87b65159ae63\nimport FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// This transaction sets up an account to use a staking collection\n/// It will work regardless of whether they have a regular account, a two-account locked tokens setup,\n/// or staking objects stored in the unlocked account\n\ntransaction {\n    prepare(signer: auth(BorrowValue, Storage, Capabilities) \u0026Account) {\n\n        // If there isn't already a staking collection\n        if signer.storage.borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath) == nil {\n\n            // Create private capabilities for the token holder and unlocked vault\n            let lockedHolder = signer.capabilities.storage.issue\u003cauth(FungibleToken.Withdraw, LockedTokens.TokenOperations) \u0026LockedTokens.TokenHolder\u003e(LockedTokens.TokenHolderStoragePath)!\n            let flowToken = signer.capabilities.storage.issue\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(/storage/flowTokenVault)!\n\n            // Create a new Staking Collection and put it in storage\n            if lockedHolder.check() {\n                signer.storage.save(\n                    \u003c- FlowStakingCollection.createStakingCollection(\n                        unlockedVault: flowToken,\n                        tokenHolder: lockedHolder\n                    ),\n                    to: FlowStakingCollection.StakingCollectionStoragePath\n                )\n            } else {\n                signer.storage.save(\n                    \u003c- FlowStakingCollection.createStakingCollection(\n                        unlockedVault: flowToken,\n                        tokenHolder: nil\n                    ),\n                    to: FlowStakingCollection.StakingCollectionStoragePath\n                )\n            }\n\n            // Publish a capability to the created staking collection.\n            let stakingCollectionCap = signer.capabilities.storage.issue\u003c\u0026FlowStakingCollection.StakingCollection\u003e(\n                FlowStakingCollection.StakingCollectionStoragePath\n            )\n\n            signer.capabilities.publish(\n                stakingCollectionCap,\n                at: FlowStakingCollection.StakingCollectionPublicPath\n            )\n        }\n\n        // borrow a reference to the staking collection\n        let collectionRef = signer.storage.borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow staking collection reference\")\n\n        // If there is a node staker object in the account, put it in the staking collection\n        if signer.storage.borrow\u003c\u0026FlowIDTableStaking.NodeStaker\u003e(from: FlowIDTableStaking.NodeStakerStoragePath) != nil {\n            let node \u003c- signer.storage.load\u003c@FlowIDTableStaking.NodeStaker\u003e(from: FlowIDTableStaking.NodeStakerStoragePath)!\n            collectionRef.addNodeObject(\u003c-node, machineAccountInfo: nil)\n        }\n\n        // If there is a delegator object in the account, put it in the staking collection\n        if signer.storage.borrow\u003c\u0026FlowIDTableStaking.NodeDelegator\u003e(from: FlowIDTableStaking.DelegatorStoragePath) != nil {\n            let delegator \u003c- signer.storage.load\u003c@FlowIDTableStaking.NodeDelegator\u003e(from: FlowIDTableStaking.DelegatorStoragePath)!\n            collectionRef.addDelegatorObject(\u003c-delegator)\n        }\n    }\n}\n",
      "arguments": [],
      "network": "mainnet",
      "hash": "69f30decc15bd78107c631e200963398e8ddbc58bb61e577d223725f348fc2d9"
    },
    {
      "id": "SCO.02",
      "name": "Register Delegator",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Registers a delegator in the staking collection resource\n/// for the specified nodeID and the amount of tokens to commit\n\ntransaction(id: String, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.registerDelegator(nodeID: id, amount: amount)      \n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "38eb95207a8f765441d110dfd46ea3c51dc69d2bcdaa9468e9ca9260609d1558"
    },
    {
      "id": "SCO.03",
      "name": "Register Node",
      "source": "import Crypto\nimport FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Registers a delegator in the staking collection resource\n/// for the specified node information and the amount of tokens to commit\n\ntransaction(id: String,\n            role: UInt8,\n            networkingAddress: String,\n            networkingKey: String,\n            stakingKey: String,\n            amount: UFix64,\n            machineAccountKey: String, \n            machineAccountKeySignatureAlgorithm: UInt8, \n            machineAccountKeyHashAlgorithm: UInt8) {\n\n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n\n        if let machineAccount = self.stakingCollectionRef.registerNode(\n            id: id,\n            role: role,\n            networkingAddress: networkingAddress,\n            networkingKey: networkingKey,\n            stakingKey: stakingKey,\n            amount: amount,\n            payer: account\n        ) {\n            let sigAlgo = SignatureAlgorithm(rawValue: machineAccountKeySignatureAlgorithm)\n                ?? panic(\"Cannot register node with provided machine account key: Must provide a signature algorithm raw value that corresponds to \"\n                .concat(\"one of the available signature algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(machineAccountKeySignatureAlgorithm.toString())\n                .concat(\" but the options are either 1 (ECDSA_P256), 2 (ECDSA_secp256k1), or 3 (BLS_BLS12_381).\"))\n\n            let hashAlgo = HashAlgorithm(rawValue: machineAccountKeyHashAlgorithm)\n                ?? panic(\"Cannot register node with the provided machine account key: Must provide a hash algorithm raw value that corresponds to \"\n                .concat(\"one of of the available hash algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(machineAccountKeyHashAlgorithm.toString())\n                .concat(\" but the options are 1 (SHA2_256), 2 (SHA2_384), 3 (SHA3_256), \")\n                .concat(\"4 (SHA3_384), 5 (KMAC128_BLS_BLS12_381), or 6 (KECCAK_256).\"))\n            \n            let publicKey = PublicKey(\n\t\t\t    publicKey: machineAccountKey.decodeHex(),\n\t\t\t    signatureAlgorithm: sigAlgo\n\t\t    )\n            machineAccount.keys.add(publicKey: publicKey, hashAlgorithm: hashAlgo, weight: 1000.0)\n        }\n    }\n}",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "role",
          "label": "Node Role",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingAddress",
          "label": "Networking Address",
          "sampleValues": [
            {
              "value": "flow-node.test:3569",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingKey",
          "label": "Networking Key",
          "sampleValues": [
            {
              "value": "1348307bc77c688e80049de9d081aa09755da33e6997605fa059db2144fc85e560cbe6f7da8d74b453f5916618cb8fd392c2db856f3e78221dc68db1b1d914e4",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "stakingKey",
          "label": "Staking Key",
          "sampleValues": [
            {
              "value": "8dec36ed8a91e3e5d737b06434d94a8a561c7889495d6c7081cd5e123a42124415b9391c9b9aa165c2f71994bf9607cb0ea262ad162fec74146d1ebc482a33b9dad203d16a83bbfda89b3f6e1cd1d8fb2e704a162d259a0ac9f26bc8635d74f6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        },
        {
          "type": "String",
          "name": "machineAccountKey",
          "label": "Machine Account Public Key",
          "sampleValues": [
            {
              "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "machineAccountKeySignatureAlgorithm",
          "label": "Raw Value for Machine Account Signature Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "machineAccountKeyHashAlgorithm",
          "label": "Raw Value for Machine Account Hash Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "22e2423dd307906e5f880eda3701664c81291142c1a1f82c71f31608f5b4a553"
    },
    {
      "id": "SCO.04",
      "name": "Create Machine Account",
      "source": "import Crypto\nimport FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Creates a machine account for a node that is already in the staking collection\n/// and adds public keys to the new account\n\ntransaction(nodeID: String, \n            machineAccountKey: String, \n            machineAccountKeySignatureAlgorithm: UInt8, \n            machineAccountKeyHashAlgorithm: UInt8) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        pre {\n\t\t\tmachineAccountKeySignatureAlgorithm == 1 || machineAccountKeySignatureAlgorithm == 2:\n                \"Cannot create machine account: Must provide a signature algorithm raw value that corresponds to \"\n                .concat(\"one of the available signature algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(machineAccountKeySignatureAlgorithm.toString())\n                .concat(\" but the options are either 1 (ECDSA_P256) or 2 (ECDSA_secp256k1).\")\n\t\t\tmachineAccountKeyHashAlgorithm == 1 || machineAccountKeyHashAlgorithm == 3:\n                \"Cannot create machine account: Must provide a hash algorithm raw value that corresponds to \"\n                .concat(\"one of of the available hash algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(machineAccountKeyHashAlgorithm.toString())\n                .concat(\" but the options are either 1 (SHA2_256) or 3 (SHA3_256).\")\n\t\t}\n\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n\n        if let machineAccount = self.stakingCollectionRef.createMachineAccountForExistingNode(nodeID: nodeID, payer: account) {\n            let sigAlgo = SignatureAlgorithm(rawValue: machineAccountKeySignatureAlgorithm)!\n\n            let hashAlgo = HashAlgorithm(rawValue: machineAccountKeyHashAlgorithm)!\n            \n            let publicKey = PublicKey(\n\t\t\t    publicKey: machineAccountKey.decodeHex(),\n\t\t\t    signatureAlgorithm: sigAlgo\n\t\t    )\n            machineAccount.keys.add(publicKey: publicKey, hashAlgorithm: hashAlgo, weight: 1000.0)\n        } else {\n            panic(\"Could not create a machine account for the node\")\n        }\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "machineAccountKey",
          "label": "Machine Account Public Key",
          "sampleValues": [
            {
              "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "machineAccountKeySignatureAlgorithm",
          "label": "Raw Value for Machine Account Signature Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "machineAccountKeyHashAlgorithm",
          "label": "Raw Value for Machine Account Hash Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "477526abb6b1a83c4163b2bb1f77eb4a9979ec510b81b4e110df003e0b586a63"
    },
    {
      "id": "SCO.05",
      "name": "Request Unstaking",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Requests unstaking for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.requestUnstaking(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "d65801ecd6852107d15a97d3b02db8226b86384e1be849fe50f1d02f7dbf5af6"
    },
    {
      "id": "SCO.06",
      "name": "Stake New Tokens",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Commits new tokens to stake for the specified node or delegator in the staking collection\n/// The tokens from the locked vault are used first, if it exists\n/// followed by the tokens from the unlocked vault\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.stakeNewTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "adc143943ac8b73c9995c45d7f3130f7e81a6ddfe72bca681ef5df7fcf6063a3"
    },
    {
      "id": "SCO.07",
      "name": "Stake Rewarded Tokens",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Commits rewarded tokens to stake for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.stakeRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "e80bcf35c25a0296b2afd99a156734e1ef37e3b244a4400faa98811e6305caf6"
    },
    {
      "id": "SCO.08",
      "name": "Stake Unstaked Tokens",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Commits unstaked tokens to stake for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.stakeUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "510ae0b5b3b89491b64a06054ce23989e1bd02fb3dac9bbca85f61a559f3364c"
    },
    {
      "id": "SCO.09",
      "name": "Unstake All",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Requests to unstake ALL tokens for the specified node or delegator in the staking collection\n\ntransaction(nodeID: String) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.unstakeAll(nodeID: nodeID)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "0dbf1bee6213b0828c0ba2a51ba0a20660ed6c7ab6632f75aac1ed669ed64bf8"
    },
    {
      "id": "SCO.10",
      "name": "Withdraw Rewarded Tokens",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Request to withdraw rewarded tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.withdrawRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            },
            {
              "value": null,
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "6239034e2884a0e32047bab081f4f2c9bdb4dba2ced6120a2d2c2f6489757868"
    },
    {
      "id": "SCO.11",
      "name": "Withdraw Unstaked Tokens",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Request to withdraw unstaked tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault if it is there\n\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.withdrawUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": null,
              "type": "Optional"
            },
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "df691ad256dd053350e48313ca5b02dda34376376bb4303d997dc8679996fe3b"
    },
    {
      "id": "SCO.12",
      "name": "Close Stake",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n// Closes out a staking object in the staking collection\n// This does not remove the record from the identity table,\n// but it does mean that the account that closes it cannot ever access it again\n\ntransaction(nodeID: String, delegatorID: UInt32?) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.closeStake(nodeID: nodeID, delegatorID: delegatorID)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32?",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": {
                "value": "42",
                "type": "UInt32"
              },
              "type": "Optional"
            },
            {
              "value": null,
              "type": "Optional"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "0c5f7a439634e49bb748df52d81074bb4ec44a940ce57ebf635522d82e1bb839"
    },
    {
      "id": "SCO.13",
      "name": "Transfer Node",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n// Transfers a NodeStaker object from an authorizers account\n// and adds the NodeStaker to another accounts Staking Collection\n// identified by the to Address.\n\ntransaction(nodeID: String, to: Address) {\n    let fromStakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        // The account to transfer the NodeStaker object to must have a valid Staking Collection in order to receive the NodeStaker.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(FlowStakingCollection.getCollectionMissingError(to))\n        }\n\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n\n        // Get the PublicAccount of the account to transfer the NodeStaker to. \n        let toAccount = getAccount(to)\n\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.capabilities\n            .borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(FlowStakingCollection.StakingCollectionPublicPath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(to))\n\n        let machineAccountInfo = self.fromStakingCollectionRef.getMachineAccounts()[nodeID]\n            ?? panic(\"Could not get machine account info from the signer's account for the node ID \"\n                    .concat(nodeID).concat(\". Make sure that the node has configured a machine account \")\n                    .concat(\"and has it registered in the staking collection.\"))\n\n        // Remove the NodeStaker from the authorizers StakingCollection.\n        let nodeStaker \u003c- self.fromStakingCollectionRef.removeNode(nodeID: nodeID)\n\n        // Deposit the NodeStaker to the receivers StakingCollection.\n        self.toStakingCollectionCap.addNodeObject(\u003c- nodeStaker!, machineAccountInfo: machineAccountInfo)\n    }\n}",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "Address",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "732bc7a1fc6359cf51b9c884ab49f22aa9cef11044332519700ed14a59cbc02c"
    },
    {
      "id": "SCO.14",
      "name": "Transfer Delegator",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n// Transfers a NodeDelegator object from an authorizers account\n// and adds the NodeDelegator to another accounts Staking Collection\n// identified by the to Address.\n\ntransaction(nodeID: String, delegatorID: UInt32, to: Address) {\n    let fromStakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        // The account to transfer the NodeDelegator object to must have a valid Staking Collection in order to receive the NodeDelegator.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(FlowStakingCollection.getCollectionMissingError(to))\n        }\n\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n\n        // Get the PublicAccount of the account to transfer the NodeDelegator to. \n        let toAccount = getAccount(to)\n\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.capabilities\n            .borrow\u003c\u0026FlowStakingCollection.StakingCollection\u003e(FlowStakingCollection.StakingCollectionPublicPath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(to))\n    }\n\n    execute {\n        // Remove the NodeDelegator from the authorizers StakingCollection.\n        let nodeDelegator \u003c- self.fromStakingCollectionRef.removeDelegator(nodeID: nodeID, delegatorID: delegatorID)\n\n        // Deposit the NodeDelegator to the receivers StakingCollection.\n        self.toStakingCollectionCap.addDelegatorObject(\u003c- nodeDelegator!)\n    }\n}",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt32",
          "name": "delegatorID",
          "label": "Delegator ID",
          "sampleValues": [
            {
              "value": "42",
              "type": "UInt32"
            }
          ]
        },
        {
          "type": "Address",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "0xe467b9dd11fa00df",
              "type": "Address"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "6a9ff4739ad11f57409823e907d8fdc23bea2ab99bb5925fafcdfeec62457fc3"
    },
    {
      "id": "SCO.15",
      "name": "Withdraw From Machine Account",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Request to withdraw tokens from the machine account\n/// The tokens are automatically deposited to the unlocked account vault\n\ntransaction(nodeID: String, amount: UFix64) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.withdrawFromMachineAccount(nodeID: nodeID, amount: amount)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "dcd4dd5d4466c1e2656f29585b48a32c9545247a2cb8a8653613272c7cc58f6c"
    },
    {
      "id": "SCO.16",
      "name": "Update Networking Address",
      "source": "import FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Changes the networking address for the specified node\n\ntransaction(nodeID: String, newAddress: String) {\n    \n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n    }\n\n    execute {\n        self.stakingCollectionRef.updateNetworkingAddress(nodeID: nodeID, newAddress: newAddress)\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "nodeID",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "address",
          "label": "Address",
          "sampleValues": [
            {
              "value": "flow-node.test:3569",
              "type": "String"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "bffd96e1dfbdd84526b77e3056a0f54999c593b4db10f864d6b1461edac265ed"
    },
    {
      "id": "SCO.17",
      "name": "Register Node with PoP",
      "source": "import Crypto\nimport FlowStakingCollection from 0x8d0e87b65159ae63\n\n/// Registers a delegator in the staking collection resource\n/// for the specified node information and the amount of tokens to commit\n\ntransaction(id: String,\n            role: UInt8,\n            networkingAddress: String,\n            networkingKey: String,\n            stakingKey: String,\n            stakingKeyPoP: String,\n            amount: UFix64,\n            machineAccountKey: String, \n            machineAccountKeySignatureAlgorithm: UInt8, \n            machineAccountKeyHashAlgorithm: UInt8) {\n\n    let stakingCollectionRef: auth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        pre {\n\t\t\tmachineAccountKeySignatureAlgorithm == 1 || machineAccountKeySignatureAlgorithm == 2:\n                \"Cannot register node with provided machine account key: Must provide a signature algorithm raw value that corresponds to \"\n                .concat(\"one of the available signature algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(machineAccountKeySignatureAlgorithm.toString())\n                .concat(\" but the options are either 1 (ECDSA_P256) or 2 (ECDSA_secp256k1).\")\n\t\t\tmachineAccountKeyHashAlgorithm == 1 || machineAccountKeyHashAlgorithm == 3:\n                \"Cannot register node with provided machine account key: Must provide a hash algorithm raw value that corresponds to \"\n                .concat(\"one of of the available hash algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(machineAccountKeyHashAlgorithm.toString())\n                .concat(\" but the options are either 1 (SHA2_256) or 3 (SHA3_256).\")\n\t\t}\n\n        self.stakingCollectionRef = account.storage.borrow\u003cauth(FlowStakingCollection.CollectionOwner) \u0026FlowStakingCollection.StakingCollection\u003e(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(FlowStakingCollection.getCollectionMissingError(nil))\n\n        if let machineAccount = self.stakingCollectionRef.registerNode(\n            id: id,\n            role: role,\n            networkingAddress: networkingAddress,\n            networkingKey: networkingKey,\n            stakingKey: stakingKey,\n            stakingKeyPoP: stakingKeyPoP,\n            amount: amount,\n            payer: account\n        ) {\n            let sigAlgo = SignatureAlgorithm(rawValue: machineAccountKeySignatureAlgorithm)!\n\n            let hashAlgo = HashAlgorithm(rawValue: machineAccountKeyHashAlgorithm)!\n            \n            let publicKey = PublicKey(\n\t\t\t    publicKey: machineAccountKey.decodeHex(),\n\t\t\t    signatureAlgorithm: sigAlgo\n\t\t    )\n            machineAccount.keys.add(publicKey: publicKey, hashAlgorithm: hashAlgo, weight: 1000.0)\n        }\n    }\n}\n",
      "arguments": [
        {
          "type": "String",
          "name": "id",
          "label": "Node ID",
          "sampleValues": [
            {
              "value": "88549335e1db7b5b46c2ad58ddb70b7a45e770cc5fe779650ba26f10e6bae5e6",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "role",
          "label": "Node Role",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingAddress",
          "label": "Networking Address",
          "sampleValues": [
            {
              "value": "flow-node.test:3569",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "networkingKey",
          "label": "Networking Key",
          "sampleValues": [
            {
              "value": "1348307bc77c688e80049de9d081aa09755da33e6997605fa059db2144fc85e560cbe6f7da8d74b453f5916618cb8fd392c2db856f3e78221dc68db1b1d914e4",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "stakingKey",
          "label": "Staking Key",
          "sampleValues": [
            {
              "value": "8dec36ed8a91e3e5d737b06434d94a8a561c7889495d6c7081cd5e123a42124415b9391c9b9aa165c2f71994bf9607cb0ea262ad162fec74146d1ebc482a33b9dad203d16a83bbfda89b3f6e1cd1d8fb2e704a162d259a0ac9f26bc8635d74f6",
              "type": "String"
            }
          ]
        },
        {
          "type": "String",
          "name": "stakingKeyPoP",
          "label": "Staking Key PoP",
          "sampleValues": [
            {
              "value": "828a68a2be392804044d85888100462702a422901da3269fb6512defabad07250aad24f232671e4ac8ae531f54e062fc",
              "type": "String"
            }
          ]
        },
        {
          "type": "UFix64",
          "name": "amount",
          "label": "Amount",
          "sampleValues": [
            {
              "value": "92233720368.54775808",
              "type": "UFix64"
            }
          ]
        },
        {
          "type": "String",
          "name": "machineAccountKey",
          "label": "Machine Account Public Key",
          "sampleValues": [
            {
              "value": "f845b8406e4f43f79d3c1d8cacb3d5f3e7aeedb29feaeb4559fdb71a97e2fd0438565310e87670035d83bc10fe67fe314dba5363c81654595d64884b1ecad1512a64e65e020164",
              "type": "String"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "machineAccountKeySignatureAlgorithm",
          "label": "Raw Value for Machine Account Signature Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        },
        {
          "type": "UInt8",
          "name": "machineAccountKeyHashAlgorithm",
          "label": "Raw Value for Machine Account Hash Algorithm Enum",
          "sampleValues": [
            {
              "value": "1",
              "type": "UInt8"
            }
          ]
        }
      ],
      "network": "mainnet",
      "hash": "88bdc9bb28ce734d1edc4b64ae5adf99ff3ac572dbe0d09090795bf78c7c31a6"
    }
  ]
}