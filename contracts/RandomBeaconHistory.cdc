/// RandomBeaconHistory (FLIP 123)
///
/// This contract stores the history of random sources generated by the Flow network. The defined Heartbeat resource is
/// updated by the Flow Service Account at the end of every block with that block's source of randomness.
///
/// While the source values are random, generated by the Random Beacon and transmitted into the execution 
/// environment via the committing transaction, using the raw values from this contract does not guarantee secure
/// randomness. The Hearbeat is intended to be used in conjunction with a pseudo-random number generator (PRNG)
/// construct and commit-reveal mechanism to provide an onchain source of secure, non-revertible randomness.
///
/// Read the full FLIP here: https://github.com/onflow/flips/pull/123
///
pub contract RandomBeaconHistory {

    /// The height at which the first source of randomness was recorded
    access(contract) var initHeight: UInt64?
    /// Sequence of random sources recorded by the Heartbeat, stored as an array over a mapping to reduce storage
    access(contract) let randomSourceHistory: [[UInt8]]
    
    /// The path of the Heartbeat resource in the deployment account
    pub let HeartbeatStoragePath: StoragePath

    /* --- Events --- */
    //
    pub event HearbeatInitialized(atBlockHeight: UInt64)
    pub event NewSourceOfRandomness(atBlockHeight: UInt64, randomSource: [UInt8])

    /* --- Hearbeat --- */
    //
    /// The Heartbeat resource containing each block's source of randomness in sequence
    ///
    pub resource Heartbeat {

        /// Callable by owner of the Heartbeat resource, Flow Service Account, records the provided random source
        ///
        /// @param randomSourceHistory The random source to record
        ///
        pub fun heartbeat(randomSourceHistory: [UInt8]) {
            let now = getCurrentBlock().height
            if RandomBeaconHistory.initHeight == nil {
                RandomBeaconHistory.initHeight = now
                emit HearbeatInitialized(atBlockHeight: now)
            }
            RandomBeaconHistory.randomSourceHistory.append(randomSourceHistory)
            emit NewSourceOfRandomness(atBlockHeight: now, randomSource: randomSourceHistory)
        }
    }

    /// Getter for the source of randomness at a given block height. Panics if the requested block height either
    /// precedes or exceeds the recorded history. Note that a source of randomness for block n will not be accessible
    /// until block n+1.
    ///
    /// @param atBlockHeight The block height at which to retrieve the source of randomness
    /// @return The source of randomness at the given block height
    ///
    pub fun sourceOfRandomness(atBlockHeight: UInt64): [UInt8] {
        pre {
            self.initHeight != nil: "Heartbeat has not been initialized"
            atBlockHeight >= self.initHeight!: "Requested block height precedes recorded history"
            atBlockHeight < getCurrentBlock().height: "Source of randomness not yet recorded"
        }
        let index = UInt64(atBlockHeight - self.initHeight!)

        assert(
            index >= 0 && index < UInt64(self.randomSourceHistory.length),
            message: "Problem finding random source history index"
        )

        return self.randomSourceHistory[index]
    }

    /// Getter for the totality of recorded randomness source history
    ///
    /// @return An array of random sources, each source an array of UInt8
    ///
    pub fun getRandomSourceHistory(): [[UInt8]] {
        pre {
            self.initHeight != nil: "Heartbeat has not been initialized"
        }
        return self.randomSourceHistory
    }

    /// Getter for the block height at which the first source of randomness was recorded
    ///
    /// @return The block height at which the first source of randomness was recorded
    ///
    pub fun getInitHeight(): UInt64 {
        return self.initHeight ?? panic("Heartbeat has not been initialized")
    }

    init() {
        self.initHeight = nil
        self.randomSourceHistory = []
        self.HeartbeatStoragePath = /storage/FlowRandomBeaconHistoryHeartbeat

        self.account.save(<-create Heartbeat(), to: self.HeartbeatStoragePath)
    }
}
